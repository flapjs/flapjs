{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./res/ServiceWorker.js","webpack:///(webpack)/buildin/global.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ServiceCache","this","_name","_assets","_handlers","asset","push","handler","request","url","result","GENERATED_ASSETS","global","serviceWorkerOption","assets","APP_CACHE","hash","process","register","addCacheStrategyHandler","test","pathname","cacheStrategyNetworkFirst","destination","cacheStrategyCacheFirst","forEach","ACTIVE_CACHES","ACTIVE_CACHE_NAMES","map","e","getName","activeCache","fetchFromNetwork","console","error","then","response","fetchFromCache","createCache","cacheName","Error","log","length","caches","open","cache","addAll","addToCache","status","type","cacheRequest","clone","cacheResponse","put","match","ownedCacheName","fetchRequest","fetch","self","addEventListener","event","results","cacheAssets","getAssets","skipWaiting","waitUntil","Promise","all","whitelist","keys","cacheNames","includes","clients","claim","requestURL","URL","method","origin","location","cacheStrategy","getCacheStrategy","respondWith","g","Function","window"],"mappings":"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","file":"serviceWorker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","//IMPORTANT: First line of file must NEVER contain code.\n//IMPORTANT: Must NEVER rename this file.\n//IMPORTANT: Must be at the root of all intercepted fetches.\n//IMPORTANT: To trigger an update, this file must change. (hopefully this will be automated)\n\n//Be careful about hosting services, they sometimes cache service workers, which\n//would stop them from automatically updating...\n\nclass ServiceCache\n{\n  constructor(name) { this._name = name; this._assets = []; this._handlers = [] }\n  register(asset) { this._assets.push(asset); return this; }\n  addCacheStrategyHandler(handler) { this._handlers.push(handler.bind(this)); return this; }\n  getAssets() { return this._assets; }\n  getName() { return this._name; }\n  getCacheStrategy(request, url)\n  {\n    //console.log(\"[ServiceWorker] Getting cache strategy for \\'\" + url.pathname + \"\\'...\");\n    let result;\n    //Gettin cache strategies...\n    for (const handler of this._handlers) if (result = handler(request, url)) return result;\n    //Could not find valid strategy for request...\n    return null;\n  }\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** CONFIGURATIONS **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\n//For debuggin' purposes, since this will turn off offline caching\nconst FORCE_NETWORK_ONLY = process.env.NODE_ENV === 'development';\n//If you can guarantee to NEVER do lazy-loading pre-cached assets,\n//then this will allow users to get the new ServiceWorker immediately,\n//rather than wait for a redirect (must close browser, then re-enter)\n//before it updates / gets new changes.\nconst FORCE_IMMEDIATE_CLAIM = true;\n//Will invalidate user's cache every build, regardless of version.\n//NOTE: Turn this on for aggressive updates.\nconst USE_CACHE_BUILD_HASH = false;\n\n//Array of assets and a build hash generated by webpack,\n//through the courtesy of ServiceWorkerWebpackPlugin.\nconst GENERATED_ASSETS = global.serviceWorkerOption.assets;\nconst GENERATED_HASH = global.serviceWorkerOption.hash;\n\n//NOTE: If you are debugging service worker (for I will salute you and wish you\n//good luck), here are some ways to make it easier for you:\n//- You should remove 'host' in the 'devServer' in 'webpack.config.js', this\n//will enable you to test it with hmr (start the test server by 'npm start').\n//- You will also need to copy this file out to the base directory and\n//replace 'serviceWorker.js' (needs to be the same name). Just edit that copy\n//until all the bugs are fixed and then copy back. (Make sure not to run a\n//production build, since that will 'clean' your edited files...)\n//- Also, since optimizations are not computed during development mode, you need\n//to uncomment 'app.bundle.js' below (don't need runtime, vendors, etc.).\n//- Finally, change the cache name to something static like 'app-test', because\n//'global.' and 'process.env.' are no longer available. You'll need to comment\n//them out.\n\n//NOTE: Another tip, any time you are debugging a new feature, be sure to try\n//it with 'offline' mode and 'disable cache' mode on/off. Sometimes, the\n//service worker will cache things that the browser already cached, making\n//your updates futile. So watch out. Until we get a proper server with\n//HTTP headers, we can't tell the browser to not cache stuff.\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** CACHES **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\n//List your caches here!\n\n//Inactive caches...(be sure to add them here for future reference)\n//...apparently there are none yet...\n\n//Active caches...(be sure to append them to ACTIVE_CACHES)\n//- unique cache name (must ALWAYS be different from any prior versions)\n//- assets to cache (every asset list must be disjoint from one another)\nconst APP_CACHE = new ServiceCache(process.env.TITLE + '-' + process.env.VERSION + (USE_CACHE_BUILD_HASH ? '_' + GENERATED_HASH : ''))\n  //Essential app files\n  .register('./') //Always include the root\n  //.register('./index.html')\n  .register('./404.html')\n  //.register('./dist/app.bundle.js')\n  /*\n  .register('./dist/runtime~app.bundle.js')\n  .register('./dist/vendors.bundle.js')\n  .register('./dist/styles.bundle.js')\n  */\n  //Any other output files\n  .addCacheStrategyHandler((request, url) =>\n  {\n    //Should accept 'index.html'...\n    if (/\\/$/.test(url.pathname)) return cacheStrategyNetworkFirst;\n\n    //Check if is fetch for general destination type of file asset...\n    const dest = request.destination;\n    switch (dest)\n    {\n      case 'style':\n      case 'script':\n      case 'document':\n      case 'image': return cacheStrategyCacheFirst;\n      default: return null;\n    }\n  });\nGENERATED_ASSETS.forEach(asset => APP_CACHE.register(asset));\n\n//Include active caches here...\nconst ACTIVE_CACHES = [APP_CACHE];\nconst ACTIVE_CACHE_NAMES = ACTIVE_CACHES.map(e => e.getName());\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** EVENT HANDLERS **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\nfunction onServiceWorkerInstall(event)\n{\n  //Create all active caches...\n  const results = [];\n  for (const cache of ACTIVE_CACHES)\n  {\n    const cacheName = cache.getName();\n    const cacheAssets = cache.getAssets();\n    //Create and load all assets for each active cache...\n    results.push(createCache(cacheName, cacheAssets));\n  }\n\n  if (FORCE_IMMEDIATE_CLAIM) self.skipWaiting();\n\n  //Wait for install to finish...\n  event.waitUntil(Promise.all(results));\n}\n\nfunction onServiceWorkerActivate(event)\n{\n  //Get the names of all current caches...\n  const whitelist = ACTIVE_CACHE_NAMES;\n\n  //Remove any cache not in the whitelist...\n  const result = caches.keys().then(cacheNames => Promise.all(\n    cacheNames.map(cacheName =>\n    {\n      //If the whitelist is missing the cache name, delete it...\n      if (!whitelist || !whitelist.includes(cacheName))\n      {\n        console.log(\"[ServiceWorker] Removing outdated cache \\'\" + cacheName + \"\\'...\");\n        return caches.delete(cacheName);\n      }\n      //Otherwise, keep the cache...\n    })\n  ));\n\n  //Wait for activate to finish...\n  event.waitUntil(result);\n\n  return self.clients.claim();\n}\n\nfunction onServiceWorkerFetch(event)\n{\n  //IMPORTANT: Request objects are streams, therefore can only used once! Clone it!\n  const request = event.request;\n  const requestURL = new URL(request.url);\n\n  if (!FORCE_NETWORK_ONLY &&\n    request.method === 'GET' &&\n    requestURL.origin === self.location.origin)\n  {\n    //Check for each cache, whether it accepts the request...\n    for (const cache of ACTIVE_CACHES)\n    {\n      const cacheStrategy = cache.getCacheStrategy(request, requestURL);\n      if (cacheStrategy)\n      {\n        //Change event's fetch result as resolved by strategy...\n        event.respondWith(cacheStrategy(request, cache));\n        return;\n      }\n    }\n  }\n\n  //Change event's fetch result...\n  event.respondWith(cacheStrategyNetworkFirst(request, null));\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** CACHE STRATEGIES **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\n//Only fetch from network\nfunction cacheStrategyNetworkOnly(request, activeCache)\n{\n  return fetchFromNetwork(request, null);\n}\n\n//Only fetch from cache\nfunction cacheStrategyCacheOnly(request, activeCache)\n{\n  return fetchFromCache(request);\n}\n\n//Always try to fetch network assets first (will fall back to cache if unable to)\nfunction cacheStrategyNetworkFirst(request, activeCache)\n{\n  //Get the request from the network...\n  return fetchFromNetwork(request, activeCache ? activeCache.getName() : null)\n    .catch(e => console.error(\"[ServiceWorker]\", e))\n    //If unable to, try to get it from cache...\n    .then(response => response || fetchFromCache(request));\n}\n\n//Always try to fetch cache assets first (will fall back to network if unable to)\nfunction cacheStrategyCacheFirst(request, activeCache)\n{\n  //Get the request from the network...\n  return fetchFromCache(request)\n    .catch(e => console.error(\"[ServiceWorker]\", e))\n    //If unable to, try to get it from cache...\n    .then(response => response || fetchFromNetwork(request, activeCache ? activeCache.getName() : null));\n}\n\n//Will fetch both simultaneously, and use which ever loads first\nfunction cacheStrategyFastest(request, activeCache)\n{\n  console.error(\"[ServiceWorker] Trying to use cache strategy not yet implemented\");\n  return cacheStrategyCacheFirst(request, activeCache);\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** HELPER FUNCTIONS **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\nfunction createCache(cacheName, assets = [])\n{\n  if (typeof cacheName !== 'string') throw new Error(\"Unable to create cache with unknown name\");\n\n  //DEBUG: should only be logged when installing new cached assets...\n  console.log(\"[ServiceWorker] Creating cache \\'\" + cacheName + \"\\' with \" + assets.length + \" asset(s)...\");\n\n  return caches.open(cacheName).then(cache => cache.addAll(assets));\n  //Don't catch the errors; let them be thrown :)\n}\n\nfunction addToCache(cacheName, request, response)\n{\n  if (typeof cacheName !== 'string') throw new Error(\"Unable to add to cache with unknown name\");\n  if (!request) throw new Error(\"Unable to add to cache for null request\");\n\n  //Make sure it's a valid response...\n  if (!response || response.status !== 200 || response.type !== 'basic') return response;\n\n  //IMPORTANT: Request objects are only used once!\n  const cacheRequest = request.clone();\n  const cacheResponse = response.clone();\n\n  //Asynchronously add to cache\n  caches.open(cacheName).then(cache => cache.put(cacheRequest, cacheResponse));\n  //Any thrown errors would be handled automatically\n\n  return response;\n}\n\nfunction fetchFromCache(request)\n{\n  if (!request) throw new Error(\"Unable to resolve fetch from cache for null request\");\n\n  return caches.match(request).then(response =>\n  {\n\n    //DEBUG: should only be logged when missing cached assets...\n    console.log(\"[ServiceWorker] Resolving fetch from cache for \\'\" + request.url + \"\\'...\");\n\n    return response;\n  });\n}\n\nfunction fetchFromNetwork(request, ownedCacheName = null)\n{\n  if (!request) throw new Error(\"Unable to resolve fetch from network for null request\");\n\n  //Make sure to not alter passed-in request...\n  const fetchRequest = request.clone();\n\n  //DEBUG: should only be logged when missing cached assets...\n  console.log(\"[ServiceWorker] Resolving fetch from network for \\'\" + request.url + \"\\'...\");\n\n  return fetch(fetchRequest).then(response =>\n  {\n    //If not caching, just return the response...\n    if (!ownedCacheName) return response;\n\n    return addToCache(ownedCacheName, request, response);\n  });\n}\n\n//Register event handlers\nself.addEventListener('install', onServiceWorkerInstall);\nself.addEventListener('activate', onServiceWorkerActivate);\nself.addEventListener('fetch', onServiceWorkerFetch);\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}