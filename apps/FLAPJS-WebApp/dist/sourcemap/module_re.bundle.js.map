{"version":3,"sources":["webpack:///./src/app/graph2/element/GraphNode.js","webpack:///./src/app/graph2/element/GraphEdge.js","webpack:///./src/app/graph2/element/GraphElement.js","webpack:///./src/app/modules/fsa2/machine/FSA.js","webpack:///./src/app/modules/fsa2/graph/element/FSAEdge.js","webpack:///./src/app/modules/fsa2/machine/util/EqualFSA.js","webpack:///./src/app/modules/fsa2/machine/util/ConvertFSA.js","webpack:///./src/app/modules/fsa2/machine/util/IntersectFSA.js","webpack:///./src/app/graph2/NodeGraph.js","webpack:///./src/app/graph2/element/QuadraticEdge.js","webpack:///./src/app/components/iconset/RunningManIcon.js","webpack:///./src/app/modules/fsa2/graph/FSAGraph.js","webpack:///./src/app/modules/fsa2/GraphLayout.js","webpack:///./src/app/modules/fsa2/machine/util/InvertDFA.js","webpack:///./src/app/session/manager/undo/AbstractEventHandler.js","webpack:///./src/app/components/iconset/flat/JSONFileIcon.js","webpack:///./src/app/session/SessionImporter.js","webpack:///./src/app/util/file/import/Importer.js","webpack:///./src/app/graph2/IndexedNodeGraph.js","webpack:///./src/app/util/Downloader.js","webpack:///./src/app/components/iconset/PageContentIcon.js","webpack:///./src/app/components/iconset/AddIcon.js","webpack:///./src/app/components/iconset/SubtractIcon.js","webpack:///./src/app/components/iconset/CheckCircleIcon.js","webpack:///./src/app/components/iconset/CrossCircleIcon.js","webpack:///./src/app/components/iconset/PendingIcon.js","webpack:///./src/app/modules/fsa2/machine/util/SolveFSA.js","webpack:///./src/app/modules/fsa2/machine/FSAUtils.js","webpack:///./src/app/modules/fsa2/graph/element/FSANode.js","webpack:///./src/app/modules/fsa2/FSAGraphParser.js","webpack:///./src/app/modules/re/machine/RE.js","webpack:///./src/app/modules/re/machine/REParser.js","webpack:///./src/app/modules/re/machine/util/ConvertRE.js","webpack:///./src/app/modules/re/ExpressionChangeHandler.js","webpack:///./src/app/modules/re/MachineController.js","webpack:///./src/app/modules/re/REErrorChecker.js","webpack:///./src/app/modules/re/components/notifications/RENotifications.js","webpack:///./src/app/modules/re/SafeExpressionEventHandler.js","webpack:///./src/app/modules/re/components/panels/overview/alphabet/AlphabetListElement.js","webpack:///./src/app/modules/re/components/panels/overview/alphabet/AlphabetListView.js","webpack:///./src/app/modules/re/components/panels/overview/OverviewPanel.js","webpack:///./src/app/modules/re/components/panels/analysis/AnalysisPanel.js","webpack:///./src/app/modules/re/components/panels/testing/TestItem.js","webpack:///./src/app/modules/re/components/panels/testing/TestListView.js","webpack:///./src/app/modules/re/components/panels/testing/TestingPanel.js","webpack:///./src/app/modules/re/components/views/ExpressionView.js","webpack:///./src/app/modules/re/filehandlers/REImporter.js","webpack:///./src/app/modules/re/filehandlers/REExporter.js","webpack:///./src/app/modules/re/filehandlers/REToFSAExporter.js","webpack:///./src/app/modules/re/REModule.js"],"names":["GraphNode","id","x","y","_label","dst","this","label","usePosition","Math","floor","GraphElement","GraphEdge","from","to","_from","_to","node","Error","HALFPI","PI","result","isPlaceholder","dy","dx","atan2","halfPlaceholderLength","getPlaceholderLength","placeholderLength","getNodeSize","src","getHashString","elementID","_id","EMPTY_SYMBOL","State","_src","getGraphElementID","guid","Transition","symbols","_symbols","slice","symbol","push","includes","join","FSA","deterministic","_states","Map","_alphabet","_transitions","_finalStates","Set","_customSymbols","_startState","_deterministic","_errors","fsa","clear","entries","key","value","copy","set","isStartState","isFinalState","add","get","getSourceState","getStateID","getDestinationState","error","length","foundSymbols","keys","values","state","transitions","getOutgoingTransitions","addState","stateID","has","size","next","getStateLabel","hasState","transitionKey","transition","hasSymbol","addSymbol","_incrSymbolCount","getSymbols","index","indexOf","_decrSymbolCount","splice","symbolCount","isCustomSymbol","newSymbol","count","cache","custom","final","forceNondeterminism","fromTransitionKey","startsWith","toState","doClosureTransition","s","i","string","stringHash","SYMBOL_SEPARATOR","EMPTY_CHAR","FSAEdge","QuadraticEdge","isEquivalentFSAWithWitness","fsa1","fsa2","isEquivalentDFA","isDeterministic","convertToDFA","dfa1","dfa2","dfa3","intersectionOfComplement","witnessString","dfa3acceptssomething","isLanguageNotEmpty","dfa4","dfa4acceptssometing","m1","m2","alphabet1","alphabet2","getAlphabet","isUsedSymbol","haveTheSameUsedAlphabet","inverted","invertDFA","intersectDFA","dfa","explored","frontier","getStartState","path","current","shift","pathUpTill","dest","setDeterministic","startState","dfaData","nfaSource","dfaStateMap","dfaFinalStates","dfaTransitionMap","dfaStartState","dfaTrapState","startStatesByClosure","getDFAStateFromNFAStates","statePowerSet","states","len","concat","getPowerSetOfStates","getStates","nfaStates","expandNFAStatesToDFA","dfaState","dfaTransitionKey","getDFATransitionKeyFromDFAStateAndSymbol","setStartState","finalState","setFinalState","addTransition","fromDFAState","nfaTerminals","fromNFAState","doTerminalTransition","nfaStateKey","nfaState","getNFAStateKeyFromNFAStates","dfaStateLabel","alphabet","checkSameAlphabet","start1","start2","pairIDs","finalPairIDs","startPair","startPairID","remainingPairIDs","parentPairID","pop","parentPair","parent1","parent2","state1","state2","doTransition","newPairID","pairToState","statePairID","statePair","createState","fromPairID","toPairID","fromState","NodeGraph","nodeClass","edgeClass","_nodeClass","_edgeClass","_nodeMapping","_edgeMapping","clearEdges","clearNodes","minX","minY","maxX","maxY","width","height","minNX","Number","MAX_VALUE","minNY","maxNX","MIN_VALUE","maxNY","maxNodeSize","min","max","minEX","minEY","maxEX","maxEY","startPoint","endPoint","centerPoint","edge","getStartPoint","getEndPoint","getCenterPoint","sx","sy","ex","ey","cx","cy","addNode","setGraphElementID","nullSourceEdges","getEdges","getEdgeFrom","getEdgeTo","setEdgeTo","deleteEdge","getNodes","getNodeLabel","Array","addEdge","getEdgeLabel","_quad","radians","coords","prevNode","setQuadraticByCoords","fromx","fromy","midpointx","midpointy","angleOffset","sqrt","outrad","inrad","maxdr","abs","getDirectionalVector","isQuadratic","getQuadraticAsCoords","px","cos","py","sin","nodeSize","getMidPoint","qcoords","qx","qy","isSelfLoop","RunningManIcon","props","className","style","xmlns","viewBox","d","React","PureComponent","FSAGraph","FSANode","IndexedNodeGraph","getReachableState","graph","reachable","startNode","getStartNode","GraphLayout","type","reachableNode","unreachable","unreachableNode","filter","numOfReachable","numOfUnreachable","numOfNode","maxNum","radius","currentStep","degree","degree_re","degree_un","toBeRejected","getFinalStates","AbstractEventHandler","undoManager","JSONFileIcon","fill","points","r","SessionImporter","app","_app","session","fileData","getApp","getUndoManager","captureEvent","sessionData","fileName","fileType","projectName","getSession","currentModule","getCurrentModule","onParseSession","onPreImportSession","onImportSession","substring","setProjectName","onPostImportSession","Promise","resolve","_nodes","prev","downloadText","filename","textData","downloadURL","encodeURIComponent","url","element","document","createElement","headerIndex","setAttribute","display","body","appendChild","click","removeChild","PageContentIcon","AddIcon","SubtractIcon","CheckCircleIcon","CrossCircleIcon","PendingIcon","MAX_COMPUTATION_STEPS","solveFSA","input","Symbol","iterator","cachedStates","cachedSymbols","relatedState","counter","solveFSAByStep","nfa","nextStates","nextIndex","cstate","nextState","_accept","_custom","JSON","parse","data","nodeDatas","nodeCount","edgeDatas","edgeCount","initialIndex","nodeIndices","nodeData","createNode","setNodeLabel","setNodeAccept","setNodeCustom","initialNode","setStartNode","edgeData","sourceNode","destinationNode","createEdge","quadData","setEdgeLabel","setQuadraticRadians","setQuadraticLength","objectify","graphNodes","graphEdges","graphInitial","accept","getNodeAccept","getNodeCustom","quad","getQuadratic","edgeSource","edgeDestination","sourceIndex","destinationIndex","nodes","edges","initial","_version","XML","nodeElements","getElementsByTagName","edgeElements","nodeElementIDs","nodeElement","nodeElementID","getAttribute","xElements","xElement","hasChildNodes","xValue","childNodes","parseFloat","nodeValue","e","yElements","yElement","yValue","initialElements","finalElements","boundingRect","getBoundingRect","transitionMapping","edgeElement","sourceID","fromElements","fromElement","fromValue","destinationID","toElements","toElement","toValue","readElements","readElement","readValue","transitionID","split","doc","DOMParser","parseFromString","structure","innerHTML","automaton","read","EMPTY","CONCAT","UNION","KLEENE","SIGMA","EMPTY_SET","PLUS","RE","expression","_expression","_terminals","re","terminal","isExpressionValid","getExpression","charAt","areParenthesisBalanced","currChar","prevChar","nextChar","setExpression","ASTNode","isTerminal","parentNode","_symbol","_isTerminal","_parent","_children","_childrenLimit","_index","childNode","hasRoomForChildren","originalChild","newChild","newChildrenLimit","REParser","rootNode","indexToNode","closedParensIndicies","regex","clearTerminals","currNode","openParenStack","char","createOpenParenNode","createUnaryOperNode","createBinaryOperNode","createTerminalNode","addTerminal","newParentNode","targetNode","originalParent","getParent","setParent","addChild","replaceChild","newNode","makeParentOf","makeParentOfParent","parentSym","getSymbol","grandparent","symbolNode","spaceIndex","scope","scopeFromCharAtIndex","parseRegex","currentNode","smallest","smallestIndexOfChildren","largest","largestIndexOfChildren","getIndex","getChildren","child","convertToNFA","prevExpression","replace","insertConcatSymbols","parser","ASTtoNFA","astNode","emptySet","terminals","getTerminals","charNFAs","character","or","sigma","kleene","a","state0","b","stateIndex","aStateMap","firstAState","newState","bStateMap","firstBState","lastBState","aTransitions","getTransitions","newFromState","newToState","newFinalState","bTransitions","stateMap","firstState","lastAState","lastState","ExpressionChangeHandler","refreshTicks","_cachedExpressionHash","_refreshTicks","_elapsedTicks","Infinity","_listeners","listener","expr","exprHash","EXPRESSION_REFRESH_RATE","MachineController","_machine","_parser","_expressionChangeHandler","_equalFSA","_equalREHash","update","setMachineExpression","hasTerminal","isSymbol","nextSymbol","nextExpression","RegExp","validate","getErrors","REErrorChecker","machineController","_machineController","_showErrorOnChange","onExpressionChange","bind","getExpressionChangeHandler","addListener","showErrors","enabled","errors","getMachine","notificationManager","getNotificationManager","clearNotifications","pushNotification","I18N","toString","SUCCESS_LAYOUT_ID","name","message","ERROR_LAYOUT_ID","SafeExpressionEventHandler","getMachineExpression","prevEvent","getPreviousEvent","applyRedo","AlphabetListElement","_inputElement","onValueChange","onFocus","onBlur","onKeyDown","onKeyUp","target","setState","select","keyCode","preventDefault","stopPropagation","blur","trim","onChange","focus","inputSymbol","displaySymbol","symbolUsed","used","Style","element_container","ref","spellCheck","maxLength","Component","TerminalListView","newSymbolComponent","useNewSymbol","onElementAdd","onElementFocus","onElementBlur","onElementChange","renameSymbol","deleteSymbol","getMachineTerminals","list_container","element_list","renderTerminalList","OverviewPanel","drawer","getMachineController","drawerFull","isDrawerFullscreen","PanelContainer","title","TITLE","PanelSection","full","Object","defineProperty","AnalysisPanel","onConvertToNFA","getExportManager","tryExportFile","analysis_button","onClick","DEFAULT_MODE","TestItem","inputElement","defaultValue","status","callback","nextValue","onDelete","onTest","active","placeholder","test_item_container","IconButton","test_button","disabled","test_input","subtitle","delete_button","ACCEPT_FILE_TYPES","TEST_FILENAME","TestListView","_testList","_testName","onTestNew","onTestUpload","onTestDownload","onTestClose","onTestAdd","onTestDelete","onTestTest","onTestRunAll","removeListener","resetStatus","isEmpty","fileBlob","reader","FileReader","onload","event","tests","test","abort","readAsText","testStrings","getValue","nextTest","item","itemValue","getEquivalentFSA","empty","test_container","test_control_tray","test_control_button","IconUploadButton","onUpload","UploadIcon","DownloadIcon","CrossIcon","test_list_container","test_list_add","test_list_count","test_list_scroll_container","test_list","map","testCallback","test_list_runall","TestingPanel","onAutoErrorCheckChange","errorChecker","getErrorChecker","errorCheck","isErrorChecking","setErrorChecking","panel_container","PanelSwitch","checked","ExpressionView","onInputChange","cursorPos","selectionStart","scopeFromSpaceIndexing","setSelectionRange","currentExpression","newExpression","isValid","readableValue","view_pane","view_widget","ExpressionViewStyle","expression_tray","tray_important","_appendSymbol","tray_symbol","REImporter","_prevExpression","machineExpression","REExporter","SessionExporter","REToFSAExporter","machine","getStateCount","formattedEdge","formatEdge","applyLayout","setGraphToFSA","graphData","JSONGraphParser","REModule","_errorChecker","getRenderManager","addRenderer","RENDER_LAYER_WORKSPACE","getDrawerManager","addPanelClass","setEventHandlerFactory","registerExporter","getImportManager","addImporter","getHotKeyManager","registerHotKey","CTRL_KEY","undo","SHIFT_KEY","redo","window","confirm","getToolbarComponent","closeBar"],"mappings":"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","file":"module_re.bundle.1238e138e478a0bc9c15.js","sourcesContent":["import GraphElement from './GraphElement.js';\n\n/**\n * A class that represents the node elements of a graph.\n *\n * @see {@link NodeGraph}\n * @extends GraphElement\n */\nclass GraphNode extends GraphElement\n{\n    /**\n   * Creates a node with the unique id.\n   * \n   * @param {String} id         the element id for this node.\n   * @param {Number} [x=0]      the initial x position\n   * @param {Number} [y=0]      the initial y position\n   */\n    constructor(id, x = 0, y = 0)\n    {\n        super(id);\n\n        this.x = x;\n        this.y = y;\n    \n        this._label = '';\n    }\n\n    /** @override */\n    getCenterPoint(dst={x: 0, y: 0})\n    {\n        dst.x = this.x;\n        dst.y = this.y;\n        return dst;\n    }\n\n    /**\n   * Sets the node label to the passed-in string.\n   *\n   * Assumes the label is NOT null.\n   * @param {String} label  The new node label.\n   * @returns {this}\n   */\n    setNodeLabel(label)\n    {\n        this._label = label;\n        return this;\n    }\n\n    /**\n   * Gets the label of the node. If the node has no label, it will return an\n   * empty string.\n   * @returns {String} The node's label.\n   */\n    getNodeLabel() { return this._label; }\n\n    /**\n   * Gets the size of the node. Can be overriden to specify a different size.\n   * @returns {Number} The radius of the node.\n   */\n    getNodeSize() { return 16; }\n\n    /** @override */\n    getHashString(usePosition=true)\n    {\n        if (usePosition)\n        {\n            return super.getHashString(usePosition) + ':' +\n        Math.floor(this.x) + ',' + Math.floor(this.y) + '.' + this._label;\n        }\n        else\n        {\n            return super.getHashString(usePosition) + ':' + this._label;\n        }\n    }\n}\n\nexport default GraphNode;\n","import GraphElement from './GraphElement.js';\n\n/**\n * A class that represents the edge elements of a graph.\n * \n * @see {@link NodeGraph}\n * @extends GraphElement\n */\nclass GraphEdge extends GraphElement\n{\n    /**\n     * Creates a edge with the unique id.\n     * \n     * @param {String} id           The element id for this node.\n     * @param {GraphNode} from      The from node of the edge.\n     * @param {GraphNode} [to=null] The to node of the edge.\n     */\n    constructor(id, from, to=null)\n    {\n        super(id);\n\n        this._from = from;\n        this._to = to;\n\n        this._label = '';\n    }\n\n    setEdgeFrom(node)\n    {\n        if (!node) throw new Error('Source of edge cannot be null');\n\n        this._from = node;\n        return this;\n    }\n\n    setEdgeTo(node)\n    {\n        this._to = node;\n        return this;\n    }\n\n    /**\n     * Sets the edge label to the passed-in string.\n     *\n     * Assumes the label is NOT null.\n     * @param {String} label  The new edge label.\n     * @returns {this}\n     */\n    setEdgeLabel(label)\n    {\n        this._label = label;\n        return this;\n    }\n\n    getEdgeDirection()\n    {\n        const from = this._from;\n        const to = this._to;\n        const HALFPI = Math.PI / 2;\n        let result = 0;\n\n        if (this.isPlaceholder())\n        {\n            result = Math.PI / 4;\n        }\n        else\n        {\n            const dy = to.y - from.y;\n            const dx = to.x - from.x;\n            result = Math.atan2(dy, dx);\n        }\n\n        if (result > HALFPI || result < -HALFPI)\n        {\n            result += Math.PI;\n        }\n\n        return result;\n    }\n\n    getStartPoint(dst = { x: 0, y: 0 })\n    {\n        const from = this._from;\n        dst.x = from.x;\n        dst.y = from.y;\n        return dst;\n    }\n\n    /** @override */\n    getCenterPoint(dst = { x: 0, y: 0 })\n    {\n        const from = this._from;\n        const to = this._to;\n        if (this.isPlaceholder())\n        {\n            const halfPlaceholderLength = this.getPlaceholderLength() / 2;\n            dst.x = from.x + halfPlaceholderLength;\n            dst.y = from.y + halfPlaceholderLength;\n        }\n        else\n        {\n            dst.x = from.x + (to.x - from.x) / 2;\n            dst.y = from.y + (to.y - from.y) / 2;\n        }\n        return dst;\n    }\n\n    getEndPoint(dst = { x: 0, y: 0 })\n    {\n        if (this.isPlaceholder())\n        {\n            const from = this._from;\n            const placeholderLength = this.getPlaceholderLength();\n            dst.x = from.x + placeholderLength;\n            dst.y = from.y + placeholderLength;\n        }\n        else\n        {\n            const to = this._to;\n            dst.x = to.x;\n            dst.y = to.y;\n        }\n        return dst;\n    }\n\n    getPlaceholderLength() { return this._from.getNodeSize(); }\n    isPlaceholder() { return this._to === null; }\n    isSelfLoop() { return this._from === this._to; }\n\n    /**\n     * Gets the label of the edge. If the edge has no label, it will return an\n     * empty string.\n     * @returns {String} The edge's label.\n     */\n    getEdgeLabel() { return this._label; }\n\n    getEdgeFrom() { return this._from; }\n    getEdgeTo() { return this._to; }\n\n    /** @override */\n    getHashString(usePosition = true)\n    {\n        const src = this._from ? this._from.getHashString(usePosition) : '';\n        // HACK: to may be a pointer, which is not a node, so getHashString does not exist.\n        const dst = this._to ? this._to.getHashString ? this._to.getHashString(usePosition) : '0' : '';\n        return super.getHashString(usePosition) + ':' + src + ',' + dst + '.' + this._label;\n    }\n}\n\nexport default GraphEdge;","/**\n * A class that represents any positioned, unique object in a graph. Usually\n * this is not instantiated, but rather extended. Look at {@link NodeElement}\n * and {@link EdgeElement} as examples.\n */\nclass GraphElement\n{\n    /**\n   * Creates an element with the unique id.\n   * \n   * @param {Number} elementID The unique id that represents the element.\n   */\n    constructor(elementID)\n    {\n        this._id = elementID;\n    }\n\n    /**\n   * Sets the element's id to the passed-in id.\n   * @param {String} elementID  The new id.\n   * @returns {this}\n   */\n    setGraphElementID(elementID)\n    {\n        this._id = elementID;\n        return this;\n    }\n\n    /**\n   * Compute the center point of the element and store the result in dst. The\n   * properties changed in dst are: x, y.\n   * @param  {Object} [dst={x: 0, y: 0}]    The object to store the result.\n   * @returns {Object}                       The passed-in dst.\n   */\n    getCenterPoint(dst = { x: 0, y: 0 })\n    {\n        dst.x = dst.y = 0;\n        return dst;\n    }\n\n    /**\n   * A unique identifier for this graph element\n   * @returns {String} The unique identifier for this element.\n   */\n    getGraphElementID() { return this._id; }\n\n    /**\n   * Computes the hash string that represents this element and its current state\n   * uniquely and deterministically. {@link NodeGraph} uses this to compute its\n   * hash code that distinguishes it from other graphs. The generated string\n   * should only be used to differentiate between other objects of the same hash\n   * function. In other words, every instance should only be compared to other\n   * instances of the same class (or extended class without override).\n   * @param  {Boolean} [usePosition=true] Whether to consider positioning as\n   *                                      part of the unique state.\n   * @returns {String}                     The hash string that represents this\n   *                                      current state.\n   */\n    getHashString(usePosition = true) { return this._id; }\n}\n\nexport default GraphElement;\n","import GraphElement from 'graph2/element/GraphElement.js';\nimport { guid, stringHash } from 'util/MathHelper.js';\n\n// const FROM_STATE_INDEX = 0;\nconst SYMBOL_INDEX = 1;\nconst TO_STATE_INDEX = 2;\n\nexport const EMPTY_SYMBOL = '&empty';\n\nexport class State\n{\n    constructor(label = '', src = null)\n    {\n        this._label = label;\n\n        this._src = src;\n        this._id = src instanceof GraphElement ? src.getGraphElementID() : guid();\n    }\n\n    copy()\n    {\n        const result = new State();\n        result._label = this._label;\n        result._src = this._src;\n        result._id = this._id;\n        return result;\n    }\n\n    getStateLabel() { return this._label; }\n\n    getStateID() { return this._id; }\n    getSource() { return this._src; }\n\n    getHashString()\n    {\n        return this._id;\n    }\n}\n\nexport class Transition\n{\n    constructor(from, to, symbols = [])\n    {\n        this._from = from;\n        this._to = to;\n        this._symbols = symbols;\n    }\n\n    copy()\n    {\n        const result = new Transition();\n        result._from = this._from;\n        result._to = this._to;\n        result._symbols = this._symbols.slice();\n        return result;\n    }\n\n    getSourceState() { return this._from; }\n    getDestinationState() { return this._to; }\n\n    addSymbol(symbol) { this._symbols.push(symbol); }\n    hasSymbol(symbol) { return this._symbols.includes(symbol); }\n    getSymbols() { return this._symbols; }\n\n    getHashString()\n    {\n        return this._from.getHashString() + ':' + this._symbols.join(',') + ':' + this._to.getHashString();\n    }\n}\n\nclass FSA\n{\n    constructor(deterministic = false)\n    {\n        //state id -> state\n        this._states = new Map();\n        //symbol -> symbol use counter\n        this._alphabet = new Map();\n        //transition key (from + to) -> transition object\n        this._transitions = new Map();\n        this._finalStates = new Set();\n        this._customSymbols = new Set();\n        this._startState = null;\n\n        this._deterministic = deterministic;\n        this._errors = [];\n    }\n\n    /**\n   * Performs a shallow copy of the 2 machines. Any changes to a state will be\n   * reflected in both. However, changes to transitions, alphabet, and final\n   * states will not propagate.\n   */\n    copy(fsa)\n    {\n        //You are already yourself, don't copy nothing.\n        if (fsa === this) return;\n\n        //Make room for the copy...\n        this.clear();\n\n        //Copy state\n        for (const [key, value] of fsa._states.entries())\n        {\n            const result = value.copy();\n            this._states.set(key, result);\n\n            //Copy start state\n            if (fsa.isStartState(value))\n            {\n                this._startState = result;\n            }\n            //Copy final states\n            if (fsa.isFinalState(value))\n            {\n                this._finalStates.add(result);\n            }\n        }\n        //Copy alphabet\n        for (const [key, value] of fsa._alphabet.entries())\n        {\n            this._alphabet.set(key, value);\n        }\n        //Copy transitions\n        for (const [key, value] of fsa._transitions.entries())\n        {\n            const result = value.copy();\n            result._from = this._states.get(value.getSourceState().getStateID());\n            result._to = this._states.get(value.getDestinationState().getStateID());\n            this._transitions.set(key, result);\n        }\n        //Copy custom symbols\n        for (const symbol of fsa._customSymbols)\n        {\n            this._customSymbols.add(symbol);\n        }\n\n        //Copy determinism\n        this._deterministic = fsa._deterministic;\n\n        //Copy errors\n        for (const error of fsa._errors)\n        {\n            //WARNING: if the error's store state objects, they need to be redirected to the copies\n            this._errors.push(error);\n        }\n    }\n\n    clear()\n    {\n        this._states.clear();\n        this._alphabet.clear();\n        this._transitions.clear();\n        this._finalStates.clear();\n        this._customSymbols.clear();\n        this._startState = null;\n\n        this._errors.length = 0;\n    }\n\n    setDeterministic(deterministic) { this._deterministic = deterministic; }\n    isDeterministic() { return this._deterministic; }\n\n    validate()\n    {\n        //Reset errors\n        this._errors.length = 0;\n\n        if (this._deterministic)\n        {\n            const foundSymbols = new Map();\n            for (const key of this._alphabet.keys())\n            {\n                foundSymbols.set(key, false);\n            }\n\n            for (const state of this._states.values())\n            {\n                //Get all outgoing transitions\n                const transitions = this.getOutgoingTransitions(state);\n                for (const transition of transitions)\n                {\n                    const symbol = transition[SYMBOL_INDEX];\n\n                    //We don't need to worry about empty symbols cause this is a DFA\n                    //So just assume every symbol is a valid one\n                    if (!foundSymbols.get(symbol))\n                    {\n                        foundSymbols.set(symbol, true);\n                    }\n                    else\n                    {\n                        //Found duplicate\n                        this._errors.push('duplicate symbol: ' + symbol);\n                        return false;\n                    }\n                }\n\n                //Reset foundSymbols for next state\n                for (const key of foundSymbols.keys())\n                {\n                    if (!foundSymbols.get(key))\n                    {\n                        //Found missing symbol for state\n                        this._errors.push('missing symbol: ' + key);\n                        return false;\n                    }\n\n                    //Reset found symbol\n                    foundSymbols.set(key, false);\n                }\n            }\n\n            //No errors found\n            this._errors.length = 0;\n            return true;\n        }\n        else\n        {\n            //It is a valid NFA already\n            this._errors.length = 0;\n            return true;\n        }\n    }\n    isValid() { return this._errors.length == 0; }\n    getErrors() { return this._errors; }\n\n    createState(label = '')\n    {\n        return this.addState(new State(label));\n    }\n\n    addState(state)\n    {\n        const stateID = state.getStateID();\n        if (this._states.has(stateID)) throw new Error('Already added state with id \\'' + stateID + '\\'');\n        //Make state as new start state if no other states exist...\n        if (this._states.size <= 0) this._startState = state;\n        //Add to state set\n        this._states.set(stateID, state);\n        return state;\n    }\n\n    removeState(state)\n    {\n        const stateID = state.getStateID();\n        if (!this._states.has(stateID)) return false;\n        this._states.delete(stateID);\n\n        //Deleted the start state, so must pick another one...\n        if (this._startState === state)\n        {\n            if (this._states.size <= 0)\n            {\n                //If no more states to choose from, don't choose anything\n                this._startState = null;\n            }\n            else\n            {\n                //Choose an arbitrary start state\n                this._startState = this._states.values().next().value;\n            }\n        }\n\n        return true;\n    }\n\n    hasStateWithLabel(label)\n    {\n        for (const state of this._states.values())\n        {\n            if (state.getStateLabel() == label)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    getStatesByLabel(label, dst = [])\n    {\n        for (const state of this._states.values())\n        {\n            if (state.getStateLabel() == label)\n            {\n                dst.push(state);\n            }\n        }\n        return dst;\n    }\n\n    getStateByID(id)\n    {\n        return this._states.get(id);\n    }\n\n    hasState(state) { return this._states.has(state.getStateID()); }\n\n    getStates() { return this._states.values(); }\n\n    getStateCount() { return this._states.size; }\n\n    addTransition(from, to, symbol)\n    {\n        if (!this.hasState(from)) throw new Error('Trying to add a transition to unknown state with label \\'' + from.getStateLabel() + '\\'');\n        if (!this.hasState(to)) throw new Error('Trying to add a transition to unknown state with label \\'' + to.getStateLabel() + '\\'');\n        if (!symbol) throw new Error('Cannot add transition for null symbol - use the empty symbol instead');\n\n        const transitionKey = from.getStateID() + '->' + to.getStateID();\n        if (this._transitions.has(transitionKey))\n        {\n            const transition = this._transitions.get(transitionKey);\n            if (!transition.hasSymbol(symbol))\n            {\n                transition.addSymbol(symbol);\n            }\n            else\n            {\n                //Didn't add anything...\n                return false;\n            }\n        }\n        else\n        {\n            this._transitions.set(transitionKey, new Transition(from, to, [symbol]));\n        }\n\n        //Add to alphabet...\n        this._incrSymbolCount(symbol);\n        return true;\n    }\n\n    removeTransition(from, to, symbol = null)\n    {\n        const transitionKey = from.getStateID() + '->' + to.getStateID();\n        if (!this._transitions.has(transitionKey)) return false;\n\n        const transition = this._transitions.get(transitionKey);\n        const symbols = transition.getSymbols();\n\n        //If deleting a specific symbol...\n        if (symbol)\n        {\n            const index = symbols.indexOf(symbol);\n            if (index >= 0)\n            {\n                //Update symbol counts...\n                this._decrSymbolCount(symbol);\n\n                symbols.splice(index, 1);\n                if (symbols.length <= 0) this._transitions.delete(transitionKey);\n                return true;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        //If deleting a all associated symbols...\n        else\n        {\n            //Update symbol counts...\n            for (const symbol of symbols)\n            {\n                this._decrSymbolCount(symbol);\n            }\n\n            //Remove transition\n            this._transitions.delete(transitionKey);\n            return true;\n        }\n    }\n\n    hasTransition(from, to, symbol = null)\n    {\n        const transitionKey = from.getStateID() + '->' + to.getStateID();\n        if (!this._transitions.has(transitionKey)) return false;\n        //Not checking for specific symbols...\n        if (!symbol) return true;\n\n        //Find the symbol...\n        return this._transitions.get(transitionKey).hasSymbol(symbol);\n    }\n\n    getTransitionSymbols(from, to)\n    {\n        const transitionKey = from.getStateID() + '->' + to.getStateID();\n        if (!this._transitions.has(transitionKey)) return null;\n        return this._transitions.get(transitionKey).getSymbols();\n    }\n\n    getTransitions() { return this._transitions.values(); }\n\n    _incrSymbolCount(symbol)\n    {\n        //Don't add empty symbol to the alphabet\n        if (symbol === EMPTY_SYMBOL) return;\n\n        const symbolCount = this._alphabet.get(symbol) || 0;\n        this._alphabet.set(symbol, symbolCount + 1);\n    }\n\n    _decrSymbolCount(symbol)\n    {\n        if (!this._alphabet.has(symbol)) throw new Error('Unable to find valid transition symbol in alphabet');\n\n        //Empty symbol is not in the alphabet\n        if (symbol === EMPTY_SYMBOL) return;\n\n        const symbolCount = this._alphabet.get(symbol);\n        //Delete the symbol, since it is no longer used...\n        if (symbolCount <= 1)\n        {\n            if (!this.isCustomSymbol(symbol))\n            {\n                //Regular symbols are removed if unused...\n                this._alphabet.delete(symbol);\n            }\n            else\n            {\n                //Custom symbols stay in the alphabet, even if unused...\n                this._alphabet.set(symbol, 0);\n            }\n        }\n        else\n        {\n            //Still being used by someone...\n            this._alphabet.set(symbol, symbolCount - 1);\n        }\n    }\n\n    changeSymbol(symbol, newSymbol)\n    {\n        if (symbol === EMPTY_SYMBOL) throw new Error('Cannot change the empty symbol');\n        if (newSymbol === EMPTY_SYMBOL) throw new Error('Cannot change to the empty symbol');\n        if (this._alphabet.has(newSymbol)) throw new Error('Cannot change symbol to another existing symbol');\n\n        for (const transition of this._transitions.values())\n        {\n            const symbols = transition.getSymbols();\n            const index = symbols.indexOf(symbol);\n\n            //Change the symbol from the transition\n            if (index >= 0)\n            {\n                symbols[index] = newSymbol;\n            }\n        }\n\n        //Exchange symbol counts...\n        const count = this._alphabet.get(symbol);\n        this._alphabet.set(newSymbol, count);\n        this._alphabet.delete(symbol);\n\n        //Check if custom symbol...\n        if (this._customSymbols.has(symbol))\n        {\n            this._customSymbols.delete(symbol);\n            this._customSymbols.add(newSymbol);\n        }\n    }\n\n    removeSymbol(symbol)\n    {\n        const cache = [];\n        for (const [key, transition] of this._transitions.entries())\n        {\n            const symbols = transition.getSymbols();\n            const index = symbols.indexOf(symbol);\n\n            //Delete the symbol from the transition\n            if (index >= 0)\n            {\n                symbols.splice(index, 1);\n\n                //If no more symbols, make sure to delete it from the map later...\n                if (symbols.length <= 0)\n                {\n                    cache.push(key);\n                }\n            }\n        }\n\n        //Delete any transitions that have no more symbols...\n        for (const transitionKey of cache)\n        {\n            this._transitions.delete(transitionKey);\n        }\n\n        //Remove from alphabet if possible...\n        if (symbol !== EMPTY_SYMBOL)\n        {\n            if (this._customSymbols.has(symbol))\n            {\n                this._alphabet.set(symbol, 0);\n            }\n            else\n            {\n                this._alphabet.delete(symbol);\n            }\n        }\n    }\n\n    setCustomSymbol(symbol, custom = true)\n    {\n        if (symbol === EMPTY_SYMBOL) throw new Error('Cannot change the empty symbol as a custom symbol');\n\n        if (custom)\n        {\n            if (!this._customSymbols.has(symbol))\n            {\n                this._customSymbols.add(symbol);\n\n                //Add symbol to alphabet if missing...\n                if (!this._alphabet.has(symbol)) this._alphabet.set(symbol, 0);\n            }\n        }\n        else\n        {\n            if (this._customSymbols.has(symbol))\n            {\n                this._customSymbols.delete(symbol);\n\n                //If symbol is unused, delete it\n                if (this._alphabet.has(symbol) && this._alphabet.get(symbol) <= 0) this._alphabet.delete(symbol);\n            }\n        }\n    }\n\n    isCustomSymbol(symbol)\n    {\n        return this._customSymbols.has(symbol);\n    }\n\n    getCustomSymbols()\n    {\n        return this._customSymbols;\n    }\n\n    clearCustomSymbols()\n    {\n        this._customSymbols.clear();\n    }\n\n    isUsedSymbol(symbol)\n    {\n        return this._alphabet.has(symbol) && this._alphabet.get(symbol) > 0;\n    }\n\n    isSymbol(symbol)\n    {\n        return this._alphabet.has(symbol);\n    }\n\n    getAlphabet()\n    {\n        return this._alphabet.keys();\n    }\n\n    setStartState(state)\n    {\n        const stateID = state.getStateID();\n        if (!this._states.has(stateID))\n        {\n            //Add it to the state set\n            this._states.set(stateID, state);\n        }\n        this._startState = state;\n    }\n    isStartState(state) { return this._startState === state; }\n    getStartState() { return this._startState; }\n\n    setFinalState(state, final = true)\n    {\n        //Make final\n        if (final)\n        {\n            //If missing from state set, add it in...\n            if (!this._states.has(state.getStateID()))\n            {\n                this.addState(state);\n            }\n\n            this._finalStates.add(state);\n        }\n        else\n        {\n            //If missing from state set, it would be effectively the same thing as\n            //calling addState(state). So due to ambiguity, don't do it.\n            if (!this._states.has(state.getStateID())) throw new Error('Trying to change final for missing state \\'' + state.getStateLabel() + '\\'');\n\n            this._finalStates.delete(state);\n        }\n    }\n    isFinalState(state) { return this._finalStates.has(state); }\n    getFinalStates() { return this._finalStates; }\n\n    doTransition(state, symbol, forceNondeterminism = false, dst = [])\n    {\n        if (!state) return dst;\n        if (!(state instanceof State)) throw new Error('Invalid state instance type \\'' + (typeof state) + '\\'');\n        if (!this._states.has(state.getStateID())) throw new Error('Unable to find source state with id \\'' + state.getStateID() + '\\'');\n\n        if (!symbol) symbol = EMPTY_SYMBOL;\n\n        const fromTransitionKey = state.getStateID() + '->';\n        for (const key of this._transitions.keys())\n        {\n            if (key.startsWith(fromTransitionKey))\n            {\n                const transition = this._transitions.get(key);\n                if (transition.hasSymbol(symbol))\n                {\n                    dst.push(transition.getDestinationState());\n\n                    //There will only ever be 1 transition for deterministic machines\n                    if (!forceNondeterminism && this._deterministic) return dst;\n                }\n            }\n        }\n        return dst;\n    }\n\n    doTerminalTransition(state, symbol, dst = [])\n    {\n        if (!state) return dst;\n        if (!this._states.has(state.getStateID())) throw new Error('Unable to find source state with id \\'' + state.getStateID() + '\\'');\n\n        if (!symbol) symbol = EMPTY_SYMBOL;\n\n        const fromTransitionKey = state.getStateID() + '->';\n        for (const key of this._transitions.keys())\n        {\n            if (key.startsWith(fromTransitionKey))\n            {\n                const transition = this._transitions.get(key);\n                if (transition.hasSymbol(symbol))\n                {\n                    const toState = transition.getDestinationState();\n                    const result = this.doClosureTransition(toState);\n                    for (const s of result)\n                    {\n                        if (!dst.includes(s)) dst.push(s);\n                    }\n                }\n            }\n        }\n\n        return dst;\n    }\n\n    doClosureTransition(state, dst = [])\n    {\n        if (!state) return dst;\n\n        dst.push(state);\n        for (let i = 0; i < dst.length; ++i)\n        {\n            const transitions = this.getOutgoingTransitions(dst[i]);\n            for (const transition of transitions)\n            {\n                if (transition[SYMBOL_INDEX] === EMPTY_SYMBOL)\n                {\n                    const toState = transition[TO_STATE_INDEX];\n                    if (!dst.includes(toState))\n                    {\n                        dst.push(toState);\n                    }\n                }\n            }\n        }\n        return dst;\n    }\n\n    getOutgoingTransitions(state, dst = [])\n    {\n        if (!state) return dst;\n        if (!this._states.has(state.getStateID())) throw new Error('Unable to find source state with id \\'' + state.getStateID() + '\\'');\n\n        const fromTransitionKey = state.getStateID() + '->';\n        for (const key of this._transitions.keys())\n        {\n            if (key.startsWith(fromTransitionKey))\n            {\n                const transition = this._transitions.get(key);\n                const symbols = transition.getSymbols();\n                for (const symbol of symbols)\n                {\n                    dst.push([state, symbol, transition.getDestinationState()]);\n                }\n            }\n        }\n\n        return dst;\n    }\n\n    getHashCode()\n    {\n        let string = '';\n        for (const state of this._states.values())\n        {\n            string += state.getHashString() + ',';\n        }\n        string += '|';\n        for (const transition of this._transitions.values())\n        {\n            string += transition.getHashString() + ',';\n        }\n        string += '|';\n        for (const state of this._finalStates)\n        {\n            string += state.getHashString();\n        }\n        string += '|';\n        string += this._startState ? this._startState.getHashString() : '';\n        string += '|';\n        string += this._deterministic ? 'd' : 'n';\n        return stringHash(string);\n    }\n}\n\nexport default FSA;\n","import QuadraticEdge from 'graph2/element/QuadraticEdge.js';\n\nexport const SYMBOL_SEPARATOR = ' ';\nexport const EMPTY_CHAR = '\\u03B5';\n\nclass FSAEdge extends QuadraticEdge\n{\n    constructor(id, from, to = null)\n    {\n        super(id, from, to);\n    }\n\n    /** @override */\n    setEdgeLabel(label)\n    {\n        if (typeof label === 'string')\n        {\n            super.setEdgeLabel(label);\n        }\n        else\n        {\n            super.setEdgeLabel(EMPTY_CHAR);\n        }\n    }\n}\n\nexport default FSAEdge;\n","import { convertToDFA } from './ConvertFSA.js';\nimport { intersectDFA } from './IntersectFSA.js';\nimport { invertDFA } from './InvertDFA.js';\n// import FSA from '../FSA.js';\n\n/**\n * @deprecated\n * Use isEquivalentFSAWithWitnessString instead.\n */\nexport function isEquivalentFSA(fsa1, fsa2)\n{\n    const dfa1 = fsa1.isDeterministic() ? fsa1 : convertToDFA(fsa1);\n    const dfa2 = fsa2.isDeterministic() ? fsa2 : convertToDFA(fsa2);\n    return isEquivalentDFA(dfa1, dfa2).value;\n}\n\nexport function isEquivalentFSAWithWitness(fsa1, fsa2)\n{\n    const dfa1 = fsa1.isDeterministic() ? fsa1 : convertToDFA(fsa1);\n    const dfa2 = fsa2.isDeterministic() ? fsa2 : convertToDFA(fsa2);\n    return isEquivalentDFA(dfa1, dfa2);\n}\n\n/*\n* this function returns an object of the form {value:boolean, witnessString:string}\n* where value is true when two DFAs describe the same language and false otherwise.\n* witnessString is a string that shows one string that demonstrates the non-equivalence\n* of the two machines of our interest. witnessString is set to null when two DFAs are \n* equivalent or when their alphabet are not the same.\n*/\nexport function isEquivalentDFA(dfa1, dfa2)\n{\n    // L(dfa3) = L(dfa1) && !L(dfa2)\n    let dfa3 = intersectionOfComplement(dfa1, dfa2);\n    if (!dfa3) \n    {\n        //console.log(\"dfa1 and dfa2 use different alphabets\");\n        return {\n            value: false,\n            witnessString: null // this means the alphabet of two machines are not the same\n        };\n    }\n    let dfa3acceptssomething = isLanguageNotEmpty(dfa3);\n    if (dfa3acceptssomething) \n    {\n        //console.log(`dfa1 accepts ${dfa3acceptssomething} while dfa2 doesn't`);\n        return {\n            value: false,\n            witnessString: dfa3acceptssomething\n        };\n    }\n    let dfa4 = intersectionOfComplement(dfa2, dfa1);\n    if (!dfa4) \n    {\n        //console.log(\"dfa1 and dfa2 use different alphabets\");\n        return {\n            value: false,\n            witnessString: null // this means these two DFAs have different alphabet\n        };\n    }\n    let dfa4acceptssometing = isLanguageNotEmpty(dfa4);\n    if (dfa4acceptssometing) \n    {\n        //console.log(`dfa2 accepts ${dfa4acceptssomething} while dfa1 doesn't`);\n        return {\n            value: false,\n            witnessString: dfa4acceptssometing\n        }; \n    }\n\n    // if the user reached this statement, the two DFA's are equal and we should return {true, ''}\n    return {\n        value: true,\n        witnessString: null \n    };\n    // L(dfa4) = L(dfa2) && !L(dfa1)\n}\n\n// TODO: move helper functions to seperate file\n// intersection is closed for DFA\nfunction intersectionOfComplement(dfa1, dfa2)\n{\n    // Returns false if used alphabet is different, else returns the common alphabet\n    const commonAlphabet = haveTheSameUsedAlphabet(dfa1, dfa2);\n    if (!commonAlphabet)\n        return null;\n\n    const inverted = invertDFA(dfa2);\n    return intersectDFA(dfa1, inverted);\n}\n\nexport function isLanguageNotEmpty(dfa)\n{\n    //Perform BFS from start state. If a final state can be reached, then the language\n    //is not empty, and the path is a witness. Else if no final states are ever reached,\n    //the language is empty\n    const explored = [];\n    const frontier = [dfa.getStartState()];\n    const path = new Map();\n    path.set(dfa.getStartState(), '');\n\n    while (frontier.length) \n    {\n        let current = frontier.shift();\n        explored.push(current);\n        let pathUpTill = path.get(current);\n\n        if (dfa.isFinalState(current)) \n        {\n            return pathUpTill;\n        }\n        for (const transition of dfa.getOutgoingTransitions(current)) \n        {\n            let dest = transition[2];\n            if (!explored.includes(dest) && !frontier.includes(dest)) \n            {\n                frontier.push(dest);\n                let symbol = transition[1];\n                path.set(dest, pathUpTill + symbol);\n            }\n        }\n    }\n    return false;\n}\n\n// TODO: same function in intersectFSA\nfunction haveTheSameUsedAlphabet(m1, m2)\n{\n    let alphabet1 = new Set();\n    let alphabet2 = new Set();\n    for (const symbol of m1.getAlphabet()) \n    {\n        if (m1.isUsedSymbol(symbol)) \n        {\n            alphabet1.add(symbol);\n        }\n    }\n    for (const symbol of m2.getAlphabet()) \n    {\n        if (m2.isUsedSymbol(symbol)) \n        {\n            alphabet2.add(symbol);\n        }\n    }\n    if (alphabet1.size != alphabet2.size)\n        return false;\n    for (const symbol of alphabet1) \n    {\n        if (!alphabet2.has(symbol))\n            return false;\n    }\n    return alphabet1;\n}\n","import FSA, { State } from '../FSA.js';\n\nexport function convertToNFA(fsa, dst = new FSA(false))\n{\n    if (!fsa.isDeterministic())\n    {\n        dst.copy(fsa);\n        return dst;\n    }\n\n    dst.setDeterministic(false);\n    return dst;\n}\n\nexport function convertToDFA(fsa, dst = new FSA(true))\n{\n    if (fsa.isDeterministic())\n    {\n        dst.copy(fsa);\n        return dst;\n    }\n\n    dst.setDeterministic(true);\n\n    const startState = fsa.getStartState();\n\n    const dfaData = {\n        nfaSource: fsa,\n        //To keep track of dfa states in terms of nfa sets\n        dfaStateMap: new Map(),\n        //Array of final dfa states\n        dfaFinalStates: [],\n        //To keep track of dfa transitions in terms of dfa states\n        dfaTransitionMap: new Map(),\n        //The resultant dfa start state\n        dfaStartState: null,\n        //The trap state for all missing transitions\n        dfaTrapState: null\n    };\n\n    //Make new DFA start state\n    const startStatesByClosure = fsa.doClosureTransition(startState);\n    dfaData.dfaStartState = getDFAStateFromNFAStates(startStatesByClosure, dfaData);\n    dfaData.dfaTrapState = getDFAStateFromNFAStates([], dfaData);\n\n    //For every state from the NFA's powerset, add it to DFA with correct transitions\n    const statePowerSet = getPowerSetOfStates(fsa.getStates());\n    for (const nfaStates of statePowerSet)\n    {\n        //As long as it is not the empty set...\n        if (nfaStates.length > 0)\n        {\n            expandNFAStatesToDFA(nfaStates, dfaData);\n        }\n    }\n\n    //Make sure any unused symbols are added as transitions for every state...\n    for (const dfaState of dfaData.dfaStateMap.values())\n    {\n        for (const symbol of fsa.getAlphabet())\n        {\n            //If transition for symbol does not exist...\n            const dfaTransitionKey = getDFATransitionKeyFromDFAStateAndSymbol(dfaState, symbol, dfaData);\n            if (!dfaData.dfaTransitionMap.has(dfaTransitionKey))\n            {\n                dfaData.dfaTransitionMap.set(dfaTransitionKey, [dfaState, symbol, dfaData.dfaTrapState]);\n            }\n        }\n    }\n\n    //Compiled dfa data to dst\n    dst.clear();\n    //Add states\n    for (const dfaState of dfaData.dfaStateMap.values())\n    {\n        dst.addState(dfaState);\n    }\n\n    //Set start state\n    dst.setStartState(dfaData.dfaStartState);\n    //Set final states\n    for (const finalState of dfaData.dfaFinalStates)\n    {\n        dst.setFinalState(finalState);\n    }\n    //Add transitions (will also add any symbols used to alphabet)\n    for (const transition of dfaData.dfaTransitionMap.values())\n    {\n        dst.addTransition(transition[0], transition[2], transition[1]);\n    }\n    return dst;\n}\n\nfunction expandNFAStatesToDFA(nfaStates, dfaData)\n{\n    let fromDFAState = getDFAStateFromNFAStates(nfaStates, dfaData);\n    let dfaState = null;\n\n    let nfaTerminals = [];\n\n    for (const symbol of dfaData.nfaSource.getAlphabet())\n    {\n        //Get all closed reachable states...\n        for (const fromNFAState of nfaStates)\n        {\n            dfaData.nfaSource.doTerminalTransition(fromNFAState, symbol, nfaTerminals);\n        }\n\n        //If has reachable states...\n        if (nfaTerminals.length > 0)\n        {\n            dfaState = getDFAStateFromNFAStates(nfaTerminals, dfaData);\n\n            //Create transition for reachable state\n            //Should guarantee to be unique for state and symbol pair\n            const dfaTransitionKey = getDFATransitionKeyFromDFAStateAndSymbol(fromDFAState, symbol, dfaData);\n            dfaData.dfaTransitionMap.set(dfaTransitionKey, [fromDFAState, symbol, dfaState]);\n        }\n\n        //Reset list\n        nfaTerminals.length = 0;\n    }\n}\n\nfunction getNFAStateKeyFromNFAStates(nfaStates, dfaData)\n{\n    let result = '';\n    for (const nfaState of dfaData.nfaSource.getStates())\n    {\n        if (nfaStates.includes(nfaState))\n        {\n            result += 'x';\n        }\n        else\n        {\n            result += '-';\n        }\n    }\n    return result;\n}\n\nfunction getDFATransitionKeyFromDFAStateAndSymbol(dfaState, symbol, dfaData)\n{\n    return dfaState.getStateID() + ';' + symbol;\n}\n\nfunction getDFAStateFromNFAStates(nfaStates, dfaData)\n{\n    const nfaStateKey = getNFAStateKeyFromNFAStates(nfaStates, dfaData);\n    let result = dfaData.dfaStateMap.get(nfaStateKey);\n\n    //If it doesn't exist, create it...\n    if (!result)\n    {\n        let final = false;\n        //Compute the label from nfa states in set notation...\n        let dfaStateLabel = '{';\n        for (const state of nfaStates)\n        {\n            if (dfaStateLabel.length > 1)\n            {\n                dfaStateLabel += ',';\n            }\n            dfaStateLabel += state.getStateLabel();\n\n            //Check if nfa state is final state...\n            if (!final)\n            {\n                final = dfaData.nfaSource.isFinalState(state);\n            }\n        }\n        dfaStateLabel += '}';\n\n        //Create the state\n        result = new State(dfaStateLabel);\n        dfaData.dfaStateMap.set(nfaStateKey, result);\n\n        //If any nfa states is a final state, make dfa state final...\n        if (final)\n        {\n            dfaData.dfaFinalStates.push(result);\n        }\n    }\n\n    return result;\n}\n\nfunction getPowerSetOfStates(states)\n{\n    var result = [[]];\n\n    for (const state of states)\n    {\n        for (let i = 0, len = result.length; i < len; ++i)\n        {\n            result.push(result[i].concat(state));\n        }\n    }\n    return result;\n}\n","import FSA from '../FSA.js';\n// TODO: add function headers-\n\n// TODO:explain intersected FSA\nexport function intersectFSA(fsa1, fsa2, dst = new FSA(true))\n{\n    throw new Error('Unsupported operation - not yet implemented');\n}\n\nexport function intersectDFA(dfa1, dfa2, dst = new FSA(true))\n{\n    if (!checkSameAlphabet(dfa1, dfa2))\n        throw new Error('Mismatched machine alphabet');\n\n    const alphabet = dfa1.getAlphabet();\n    const start1 = dfa1.getStartState();\n    const start2 = dfa2.getStartState();\n\n    if (!start1 && !start2)\n    {\n        dst.clear();\n        return dst;\n    }\n    else if (!start1)\n    {\n        return dst.copy(dfa2);\n    }\n    else if (!start2)\n    {\n        return dst.copy(dfa1);\n    }\n\n    const pairIDs = new Map();\n    const finalPairIDs = new Set();\n    const transitions = [];\n\n    //Add start state pair\n    const startPair = [start1, start2];\n    const startPairID = start1.getStateID() + ':' + start2.getStateID();\n    if (dfa1.isFinalState(start1) && dfa2.isFinalState(start2))\n    {\n        finalPairIDs.add(startPairID);\n    }\n    pairIDs.set(startPairID, startPair);\n\n    //Add remaining states by symbol\n    const remainingPairIDs = [];\n    remainingPairIDs.push(startPairID);\n    while (remainingPairIDs.length > 0)\n    {\n        const parentPairID = remainingPairIDs.pop();\n        const parentPair = pairIDs.get(parentPairID);\n        const parent1 = parentPair[0];\n        const parent2 = parentPair[1];\n\n        const result = [];\n        for (const symbol of alphabet)\n        {\n            let state1;\n            let state2;\n\n            dfa1.doTransition(parent1, symbol, false, result);\n            if (result.length !== 1)\n            {\n                throw new Error('Found non-deterministic transition from \\'' +\n                    parent1.getStateLabel() + '\\' for \\'' + symbol + '\\' - transitions to \\'' + result.join(',') + '\\'');\n            }\n            state1 = result[0];\n            result.length = 0;\n\n            dfa2.doTransition(parent2, symbol, false, result);\n            if (result.length !== 1)\n            {\n                throw new Error('Found non-deterministic transition from \\'' +\n                    parent2.getStateLabel() + '\\' for \\'' + symbol + '\\' - transitions to \\'' + result.join(',') + '\\'');\n            }\n            state2 = result[0];\n            result.length = 0;\n\n            //Get cartesian-product equivalent\n            const newPairID = state1.getStateID() + ':' + state2.getStateID();\n            if (!pairIDs.has(newPairID))\n            {\n                pairIDs.set(newPairID, [state1, state2]);\n                remainingPairIDs.push(newPairID);\n\n                //Only accept if both do\n                if (dfa1.isFinalState(state1) && dfa2.isFinalState(state2))\n                {\n                    finalPairIDs.add(newPairID);\n                }\n            }\n\n            //Add the transition\n            transitions.push([\n                /*FROM PAIR ID*/ parentPairID,\n                /*SYMBOL*/ symbol,\n                /*TO PAIR ID*/ newPairID\n            ]);\n        }\n    }\n\n    dst.clear();\n\n    //Add state/final pairs to the machine\n    const pairToState = new Map();\n    for (const [statePairID, statePair] of pairIDs.entries())\n    {\n        const state = dst.createState('(' + statePair[0].getStateLabel() + ',' + statePair[1].getStateLabel() + ')');\n        if (finalPairIDs.has(statePairID))\n        {\n            dst.setFinalState(state, true);\n        }\n        pairToState.set(statePairID, state);\n    }\n\n    //Add start pair to the machine\n    const startState = pairToState.get(startPairID);\n    if (!startState) throw new Error('Unable to find start state for pair');\n    dst.setStartState(startState);\n\n    //Add transitions to the machine\n    for (const transition of transitions)\n    {\n        const fromPairID = transition[0];\n        const symbol = transition[1];\n        const toPairID = transition[2];\n\n        const fromState = pairToState.get(fromPairID);\n        const toState = pairToState.get(toPairID);\n        if (!fromState || !toState) throw new Error('Cannot find state for pair');\n\n        dst.addTransition(fromState, toState, symbol);\n    }\n\n    return dst;\n}\n\nfunction checkSameAlphabet(fsa1, fsa2)\n{\n    const alphabet = new Set();\n    for (let symbol of fsa1.getAlphabet()) { alphabet.add(symbol); }\n\n    for (let symbol of fsa2.getAlphabet())\n    {\n        if (!alphabet.has(symbol))\n        {\n            return false;\n        }\n        else\n        {\n            alphabet.delete(symbol);\n        }\n    }\n\n    return alphabet.size <= 0;\n}\n","import GraphNode from './element/GraphNode.js';\nimport GraphEdge from './element/GraphEdge.js';\nimport { guid, stringHash } from 'util/MathHelper.js';\n\n/**\n * A class that represents a graph that coordinates nodes and edges.\n */\nclass NodeGraph\n{\n    /**\n     * Create a NodeGraph with the respective node and edge classes.\n     * @param {Class} [nodeClass=GraphNode] The class that represents a node.\n     * @param {Class} [edgeClass=GraphEdge] The class that represents an edge.\n     */\n    constructor(nodeClass = GraphNode, edgeClass = GraphEdge)\n    {\n        this._nodeClass = nodeClass;\n        this._edgeClass = edgeClass;\n\n        this._nodeMapping = new Map();\n        this._edgeMapping = new Map();\n    }\n\n    /**\n     * Removes all nodes and edges from the graph.\n     */\n    clear()\n    {\n        this.clearEdges();\n        this.clearNodes();\n    }\n\n    /**\n     * Checks whether there exists any number of nodes or edges.\n     * @returns {Boolean} Whether the graph is empty.\n     */\n    isEmpty()\n    {\n        return this._nodeMapping.size <= 0 && this._edgeMapping.size <= 0;\n    }\n\n    /**\n     * Computes the boundaries of the graph that surrounds all nodes and edges. If\n     * the graph is empty, a rectangle at the origin of size 1 is returned.\n     * @returns {Object}    The object which represents the bounding rectangle. It has\n     *                      the properties: minX, minY, maxX, maxY, width, height.\n     */\n    getBoundingRect()\n    {\n        if (this._nodeMapping.size <= 0) return {\n            minX: 0,\n            minY: 0,\n            maxX: 1,\n            maxY: 1,\n            width: 1,\n            height: 1\n        };\n\n        var minNX = Number.MAX_VALUE;\n        var minNY = Number.MAX_VALUE;\n        var maxNX = Number.MIN_VALUE;\n        var maxNY = Number.MIN_VALUE;\n\n        var maxNodeSize = 0;\n        for (const node of this._nodeMapping.values())\n        {\n            const x = node.x;\n            const y = node.y;\n            const size = node.getNodeSize();\n            if (size > maxNodeSize) maxNodeSize = size;\n\n            minNX = Math.min(minNX, x);\n            maxNX = Math.max(maxNX, x);\n\n            minNY = Math.min(minNY, y);\n            maxNY = Math.max(maxNY, y);\n        }\n\n        minNX -= maxNodeSize;\n        minNY -= maxNodeSize;\n        maxNX += maxNodeSize;\n        maxNY += maxNodeSize;\n\n        var minEX = Number.MAX_VALUE;\n        var minEY = Number.MAX_VALUE;\n        var maxEX = Number.MIN_VALUE;\n        var maxEY = Number.MIN_VALUE;\n\n        const startPoint = { x: 0, y: 0 };\n        const endPoint = { x: 0, y: 0 };\n        const centerPoint = { x: 0, y: 0 };\n        for (const edge of this._edgeMapping.values())\n        {\n            //Will store into point objects...\n            edge.getStartPoint(startPoint);\n            edge.getEndPoint(endPoint);\n            edge.getCenterPoint(centerPoint);\n\n            const sx = startPoint.x;\n            const sy = startPoint.y;\n            const ex = endPoint.x;\n            const ey = endPoint.y;\n            const cx = centerPoint.x;\n            const cy = centerPoint.y;\n\n            minEX = Math.min(minEX, sx, ex, cx);\n            maxEX = Math.max(maxEX, sx, ex, cx);\n\n            minEY = Math.min(minEY, sy, ey, cy);\n            maxEY = Math.max(maxEY, sy, ey, cy);\n        }\n\n        const result = {\n            minX: Math.min(minNX, minEX),\n            minY: Math.min(minNY, minEY),\n            maxX: Math.max(maxNX, maxEX),\n            maxY: Math.max(maxNY, maxEY),\n            width: 0,\n            height: 0\n        };\n        result.width = result.maxX - result.minX;\n        result.height = result.maxY - result.minY;\n        return result;\n    }\n\n    /**\n     * Computes a unique and persistent hash code that describes the current\n     * state.\n     * @param  {Boolean} [usePosition=true] Whether to consider the positioning as\n     *                                      part of the graph's state.\n     * @returns {Number}                    the hash code.\n     */\n    getHashCode(usePosition = true)\n    {\n        let string = '';\n        for (const node of this._nodeMapping.values())\n        {\n            string += node.getHashString(usePosition) + ',';\n        }\n        string += '|';\n        for (const edge of this._edgeMapping.values())\n        {\n            string += edge.getHashString(usePosition) + ',';\n        }\n        return stringHash(string);\n    }\n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= NODES\n\n    /**\n     * Create node for graph.\n     * @param  {Number} [x=0]       the initial x position\n     * @param  {Number} [y=0]       the initial y position\n     * @param  {String} [id=null]   the new node id (will be generated if null)\n     * @returns {GraphNdoe}         the new node\n     */\n    createNode(x = 0, y = 0, id = null)\n    {\n        return this.addNode(new (this._nodeClass)(id || guid(), x, y));\n    }\n\n    /**\n     * Add existing node to the graph. Any edges connected to the node are NOT\n     * deleted in the process. (so pls delete them first.)\n     * @param {GraphNode} node The node to be added.\n     * @returns {GraphNode} The node that was added to the graph.\n     */\n    addNode(node)\n    {\n        if (!node.getGraphElementID()) node.setGraphElementID(guid());\n        this._nodeMapping.set(node.getGraphElementID(), node);\n        return node;\n    }\n\n    /**\n     * Delete node from graph. Any edges whose source is the target node are also\n     * deleted.\n     * @param  {GraphNode} node        Target node to be deleted.\n     */\n    deleteNode(node)\n    {\n        const elementID = node.getGraphElementID();\n        if (this._nodeMapping.has(elementID))\n        {\n            this._nodeMapping.delete(elementID);\n\n            const nullSourceEdges = [];\n            //Find connected edges without sources...\n            for (const edge of this.getEdges())\n            {\n                if (edge.getEdgeFrom() === node)\n                {\n                    nullSourceEdges.push(edge);\n                }\n                else if (edge.getEdgeTo() === node)\n                {\n                    edge.setEdgeTo(null);\n                }\n            }\n            //Delete sourceless edges...\n            for (const edge of nullSourceEdges)\n            {\n                this.deleteEdge(edge);\n            }\n        }\n    }\n\n    clearNodes() { this._nodeMapping.clear(); }\n\n    getNodeByElementID(elementID)\n    {\n        if (this._nodeMapping.has(elementID))\n        {\n            return this._nodeMapping.get(elementID);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    getNodesByLabel(label, dst = [])\n    {\n        for (const node of this.getNodes())\n        {\n            if (node.getNodeLabel() === label)\n            {\n                dst.push(node);\n            }\n        }\n        return dst;\n    }\n\n    getNodes() { return Array.from(this._nodeMapping.values()); }\n    getNodeCount() { return this._nodeMapping.size; }\n    getNodeClass() { return this._nodeClass; }\n\n    // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= EDGES\n\n    /**\n     * This is more like addEdge() without adding it to the graph and just returns the result.\n     * This should only be called once when completing an edge.\n     * @deprecated\n     */\n    formatEdge(edge)\n    {\n        return edge;\n    }\n\n    /**\n     * Create edge for graph. The id argument can be used to set the id to a\n     * pre-defined value instead of generating a new one.\n     * @param  {GraphNode} from                     the source graph node for the edge\n     * @param  {GraphNode|InputPointer} [to=null]   the destination graph node for the edge\n     * @param  {String} [id=null]                   the new edge id (will be generated if null)\n     * @returns {GraphEdge}                         the new edge\n     */\n    createEdge(from, to = null, id = null)\n    {\n        return this.addEdge(new (this._edgeClass)(id || guid(), from, to));\n    }\n\n    /**\n     * Add existing edge to the graph.\n     * \n     * Assumes that the passed-in edge does not have conflicting id's within this graph.\n     * @param {GraphEdge} edge    the edge to be added.\n     * @returns {GraphEdge}       the edge that was added to the graph.\n     */\n    addEdge(edge)\n    {\n        if (!edge.getGraphElementID()) edge.setGraphElementID(guid());\n        this._edgeMapping.set(edge.getGraphElementID(), edge);\n        return edge;\n    }\n\n    /**\n     * Delete edge from graph. The from and to nodes of the target edge are not\n     * modified.\n     * @param  {GraphEdge} edge      target edge to be deleted.\n     */\n    deleteEdge(edge)\n    {\n        const elementID = edge.getGraphElementID();\n        if (this._edgeMapping.has(elementID))\n        {\n            this._edgeMapping.delete(elementID);\n        }\n    }\n\n    clearEdges() { this._edgeMapping.clear(); }\n\n    getEdgeByElementID(elementID)\n    {\n        if (this._edgeMapping.has(elementID))\n        {\n            return this._edgeMapping.get(elementID);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    getEdgesByLabel(label, dst = [])\n    {\n        for (const edge of this.getEdges())\n        {\n            if (edge.getEdgeLabel() === label)\n            {\n                dst.push(edge);\n            }\n        }\n        return dst;\n    }\n\n    getEdges() { return Array.from(this._edgeMapping.values()); }\n    getEdgeCount() { return this._edgeMapping.size; }\n    getEdgeClass() { return this._edgeClass; }\n}\n\nexport default NodeGraph;\n","import GraphEdge from './GraphEdge.js';\nimport { getDirectionalVector, getMidPoint } from 'util/MathHelper.js';\n\n/**\n * A class that represents the curved edge elements of a graph.\n * \n * @see {@link NodeGraph}\n * @extends GraphEdge\n */\nclass QuadraticEdge extends GraphEdge\n{\n    /**\n     * Creates a quadratic edge with the unique id.\n     * @constructor\n     * @param {String} id           The element id for this node.\n     * @param {GraphNode} from      The from node of the edge.\n     * @param {GraphNode} [to=null] The to node of the edge.\n     */\n    constructor(id, from, to = null)\n    {\n        super(id, from, to);\n\n        //radians = the angle in radians, where 0 is the normal of midpoint\n        //length = the distance from midpoint\n        this._quad = {\n            radians: 0,\n            length: to ? 0 : this.getPlaceholderLength(),\n            coords: { x: 0, y: 0 }\n        };\n    }\n\n    /** @override */\n    setEdgeTo(node)\n    {\n        const prevNode = this._to;\n        if (node !== prevNode)\n        {\n            const result = super.setEdgeTo(node);\n            if (!node)\n            {\n                this.setQuadraticByCoords(prevNode.x, prevNode.y);\n            }\n            else if (node === this._from)\n            {\n                this._quad.length = this._from.getNodeSize() + this.getPlaceholderLength();\n            }\n            return result;\n        }\n        return super.setEdgeTo(node);\n    }\n\n    /**\n     * Set the angle of the curve in radians\n     * @param {Number} radians the radians the quadratic should be curved\n     * @returns {this}\n     */\n    setQuadraticRadians(radians)\n    {\n        this._quad.radians = radians;\n        return this;\n    }\n\n    /**\n     * Set the distance of the curve from the midpoint\n     * @param {Number} length the \"height\" of the curve\n     * @returns {this}\n     */\n    setQuadraticLength(length)\n    {\n        this._quad.length = length;\n        return this;\n    }\n\n    /**\n     * Calculates and sets the quadratic vertex to pass through the position.\n     * This will update the radians and length of the curve.\n     * @param {Number} x the x coordinate\n     * @param {Number} y the y coordinate\n     * @returns {this}\n     */\n    setQuadraticByCoords(x, y)\n    {\n        const from = this._from;\n        const to = this._to;\n\n        if (!to)\n        {\n            /*\n            Quad is re-used to determine edge angle for placeholder.\n            This can be used specifically for quad since regular quad is\n            dependent on edge to to NOT be null, which placeholder assumes\n            to BE null. Also, quad.length is ignored, because the\n            length should always be getPlaceholderLength(). This is\n            resolved by getStartPoint(), getEndPoint(), etc.\n            */\n            const dx = this._from.x - x;\n            const dy = this._from.y - y;\n            const radians = -Math.atan2(dx, dy) - (Math.PI / 2);\n            this._quad.radians = radians;\n            return this;\n        }\n\n        const fromx = from.x;\n        const fromy = from.y;\n        const tox = to.x;\n        const toy = to.y;\n\n        let dx = tox - fromx;\n        let dy = toy - fromy;\n        const midpointx = fromx + dx / 2;\n        const midpointy = fromy + dy / 2;\n\n        // Remember: y-axis is flipped because canvas coord-space is -y => +y\n        // Therefore, dy needs to be flipped\n        const angleOffset = Math.atan2(-dy, dx);\n        dx = x - midpointx;\n        dy = y - midpointy;\n\n        const PI = Math.PI;\n        const HALFPI = PI / 2;\n        // 0 rad = to the right\n        // Also: angleOffset is the offset from midpoint angle, the orthogonal base vector\n        // This is because the from and to could be flipped, and\n        // therefore give a negative, or at least a reversed angle.\n        let radians = Math.atan2(dy, dx) + angleOffset;\n        let length = Math.sqrt(dx * dx + dy * dy);\n        if (length < 0) length = 0;\n\n        // -PI / 2 is outward\n        const outrad = radians - (-HALFPI);\n        // PI / 2 is inward\n        const inrad = radians - (HALFPI);\n        // TODO: Should be dependent on length, instead of a constant.\n        const maxdr = PI / 20;\n\n        if (Math.abs(length) < 8)\n        {\n            radians = 0;\n            length = 0;\n        }\n        else if (outrad < maxdr && outrad > -maxdr)\n        {\n            // -PI / 2 is outward\n            radians = -HALFPI;\n        }\n        else if (-inrad < maxdr && -inrad > -maxdr)\n        {\n            // PI / 2 is inward\n            radians = HALFPI;\n        }\n\n        this._quad.radians = radians;\n        this._quad.length = length;\n        return this;\n    }\n\n    getQuadraticLength() { return this._quad.length; }\n    getQuadraticRadians() { return this._quad.radians; }\n    getQuadratic() { return this._quad; }\n    isQuadratic() { return !this.isPlaceholder() && this._quad.length !== 0; }\n\n    getQuadraticAsCoords()\n    {\n        const from = this._from;\n        const to = this._to;\n        const dst = this._quad.coords;\n        if (from == null || to == null)\n        {\n            dst.x = 0;\n            dst.y = 0;\n        }\n        else\n        {\n            /*\n            //To mark dirty...\n            _capture: {\n                fx: 0, fy: 0,\n                tx: 0, ty: 0,\n                ql: 0, qr: 0\n            }\n            */\n            getDirectionalVector(from.x, from.y, to.x, to.y, this._quad.length, this._quad.radians, dst);\n        }\n        return dst;\n    }\n\n    /** @override */\n    getEdgeDirection()\n    {\n        let result = 0;\n        if (this.isQuadratic())\n        {\n            const coords = this.getQuadraticAsCoords();\n            result = Math.atan2(coords.y, coords.x) + Math.PI / 2;\n        }\n        else\n        {\n            result = super.getEdgeDirection();\n        }\n\n        return result;\n    }\n\n    /** @override */\n    getStartPoint(dst = { x: 0, y: 0 })\n    {\n        const from = this._from;\n        const to = this._to;\n\n        if (!from) throw new Error('Source of edge cannot be null.');\n        if (!to)\n        {\n            //Make sure to use quad for placeholder direction\n            const radians = this._quad.radians;\n            const px = Math.cos(radians);\n            const py = Math.sin(radians);\n            const nodeSize = from.getNodeSize();\n            dst.x = from.x + px * nodeSize;\n            dst.y = from.y + py * nodeSize;\n            return dst;\n        }\n\n        //Check if edge is following something other than a node...then remain flat\n        if (typeof to['getNodeSize'] !== 'function' || !this.isQuadratic())\n        {\n            getDirectionalVector(from.x, from.y, to.x, to.y, from.getNodeSize(), 0, dst);\n            dst.x += from.x;\n            dst.y += from.y;\n            return dst;\n        }\n        else\n        {\n            getMidPoint(from.x, from.y, to.x, to.y, dst);\n            const qcoords = this.getQuadraticAsCoords();\n            const qx = dst.x + qcoords.x;\n            const qy = dst.y + qcoords.y;\n            getDirectionalVector(from.x, from.y, qx, qy, from.getNodeSize(), this.isSelfLoop() ? (Math.PI / 4) : 0, dst);\n            dst.x += from.x;\n            dst.y += from.y;\n            return dst;\n        }\n    }\n\n    /** @override */\n    getCenterPoint(dst = { x: 0, y: 0 })\n    {\n        const from = this._from;\n        const to = this._to;\n\n        if (!from) throw new Error('Source of edge cannot be null.');\n        if (!to)\n        {\n            //Make sure to use quad for placeholder direction (not magnitude)\n            const px = Math.cos(this._quad.radians);\n            const py = Math.sin(this._quad.radians);\n            const placeholderLength = from.getNodeSize() + this.getPlaceholderLength() / 2;\n            dst.x = from.x + px * placeholderLength;\n            dst.y = from.y + py * placeholderLength;\n            return dst;\n        }\n\n        getMidPoint(from.x, from.y, to.x, to.y, dst);\n\n        if (this.isQuadratic())\n        {\n            const qcoords = this.getQuadraticAsCoords();\n            dst.x += qcoords.x;\n            dst.y += qcoords.y;\n        }\n\n        return dst;\n    }\n\n    /** @override */\n    getEndPoint(dst = { x: 0, y: 0 })\n    {\n        const from = this._from;\n        const to = this._to;\n\n        if (!from) throw new Error('Source of edge cannot be null.');\n        if (!to)\n        {\n            //Make sure to use quadCoords for placeholder direction (not magnitude)\n            const radians = this._quad.radians;\n            const px = Math.cos(radians);\n            const py = Math.sin(radians);\n            const placeholderLength = from.getNodeSize() + this.getPlaceholderLength();\n            dst.x = from.x + px * placeholderLength;\n            dst.y = from.y + py * placeholderLength;\n            return dst;\n        }\n\n        //Get end point for non-nodes...\n        if (typeof to['getNodeSize'] !== 'function')\n        {\n            return to;\n        }\n        //Get end point for straight edges...\n        else if (!this.isQuadratic())\n        {\n            getDirectionalVector(to.x, to.y, from.x, from.y, to.getNodeSize(), 0, dst);\n            dst.x += to.x;\n            dst.y += to.y;\n            return dst;\n        }\n        //Get end point for quadratics...\n        else\n        {\n            getMidPoint(from.x, from.y, to.x, to.y, dst);\n            const qcoords = this.getQuadraticAsCoords();\n            const qx = dst.x + qcoords.x;\n            const qy = dst.y + qcoords.y;\n            getDirectionalVector(to.x, to.y, qx, qy, to.getNodeSize(), this.isSelfLoop() ? -(Math.PI / 4.0) : 0, dst);\n            dst.x += to.x;\n            dst.y += to.y;\n            return dst;\n        }\n    }\n\n    /** @override */\n    getHashString(usePosition = true)\n    {\n        if (usePosition)\n        {\n            return super.getHashString(usePosition) + ':' + this._quad.radians + ',' + this._quad.length;\n        }\n        else\n        {\n            return super.getHashString(usePosition);\n        }\n    }\n}\n\nexport default QuadraticEdge;\n","import React from 'react';\n\nclass RunningManIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n                <path d=\"M13.49 5.48c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm-3.6 13.9l1-4.4 2.1 2v6h2v-7.5l-2.1-2 .6-3c1.3 1.5 3.3 2.5 5.5 2.5v-2c-1.9 0-3.5-1-4.3-2.4l-1-1.6c-.4-.6-1-1-1.7-1-.3 0-.5.1-.8.1l-5.2 2.2v4.7h2v-3.4l1.8-.7-1.6 8.1-4.9-1-.4 2 7 1.4z\"/>\n            </svg>\n        );\n    }\n}\nexport default RunningManIcon;\n","import IndexedNodeGraph from 'graph2/IndexedNodeGraph.js';\n\nimport FSANode from './element/FSANode.js';\nimport FSAEdge from './element/FSAEdge.js';\n\nclass FSAGraph extends IndexedNodeGraph\n{\n    constructor()\n    {\n        super(FSANode, FSAEdge);\n    }\n}\n\nexport default FSAGraph;\n","\nfunction getReachableState(graph)\n{\n    let reachable = [];\n    let startNode = graph.getStartNode();\n    reachable.push(startNode);\n    for(let i = 0; i < reachable.length; i++)\n    {\n        for (const edge of graph.getEdges())\n        {\n            if(edge._from == reachable[i])\n            {\n                if(!reachable.includes(edge._to))\n                {\n                    reachable.push(edge._to);\n                }\n            }\n        }\n    }\n    return reachable;\n}\n\nclass GraphLayout\n{\n    static applyLayout(graph, type='circle')\n    {\n        if (type != 'circle') throw new Error('Invalid layout type');\n        //seperate node to reachable and unreachable\n        const reachableNode= getReachableState(graph);\n        function unreachable(node)\n        {\n            return !reachableNode.includes(node);\n        }\n        const unreachableNode = graph.getNodes().filter(unreachable);\n\n        //get num of nodes\n        const numOfReachable = reachableNode.length;\n        const numOfUnreachable = unreachableNode.length;\n        const numOfNode = graph.getNodes().length;\n        const maxNum = Math.max(numOfReachable, numOfUnreachable);\n        if(numOfNode == 0)\n        {\n            return;\n        }\n        //set radius\n        var radius;\n        if(numOfReachable < 10 && numOfUnreachable < 10)\n        {\n            radius = maxNum/4 * 50 + 30;\n        }\n        else\n        {\n            radius = (maxNum/5) * 40 + 30;\n        }\n\n        let currentStep = 0;\n        if (numOfReachable == 1)\n        {\n            let degree = 2* Math.PI/numOfNode;\n            for(const node of graph.getNodes())\n            {\n                node.y = Math.sin(degree*currentStep + Math.PI)*radius;\n                node.x = Math.cos(degree*currentStep + Math.PI)*radius;\n                currentStep += 1;\n            }\n        }\n        else \n        {\n            const degree_re = 2* Math.PI/numOfReachable;\n            const degree_un = 2* Math.PI/numOfUnreachable;\n\n            currentStep = 0;\n            for(const node of reachableNode)\n            {\n                node.y = Math.sin(degree_re*currentStep + Math.PI)*radius;\n                node.x = Math.cos(degree_re*currentStep + Math.PI)*radius;\n                currentStep += 1;\n            }\n            currentStep = 0;\n            for(const node of unreachableNode)\n            {\n                node.y = Math.sin(degree_un*currentStep + Math.PI)*(radius + 100);\n                node.x = Math.cos(degree_un*currentStep + Math.PI)*(radius + 100);\n                currentStep += 1;\n            }\n        }\n    /*for(const node of graph.getNodes())\n    {\n      node.y = Math.sin(degree*currentStep + Math.PI)*radius;\n      node.x = Math.cos(degree*currentStep + Math.PI)*radius;\n      currentStep += 1\n    }*/\n    }\n\n\n}\n\nexport default GraphLayout;\n","import FSA from '../FSA.js';\n\nexport function invertDFA(fsa, dst = new FSA(true))\n{\n    dst.copy(fsa);\n\n    const toBeRejected = new Set(dst.getFinalStates());\n    for (const state of dst.getStates())\n    {\n        if (toBeRejected.has(state))\n        {\n            dst.setFinalState(state, false);\n        }\n        else\n        {\n            dst.setFinalState(state, true);\n        }\n    }\n\n    return dst;\n}\n","class AbstractEventHandler\n{\n    constructor() {}\n\n    applyUndo(undoManager)\n    {\n        throw new Error('Undo operation for handler not supported');\n    }\n\n    applyRedo(undoManager)\n    {\n        throw new Error('Redo operation for handler not supported');\n    }\n}\n\nexport default AbstractEventHandler;\n","import React from 'react';\n\nclass JSONFileIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 56 56\">\n                <path fill=\"#E9E9E0\" d=\"M36.985,0H7.963C7.155,0,6.5,0.655,6.5,1.926V55c0,0.345,0.655,1,1.463,1h40.074 c0.808,0,1.463-0.655,1.463-1V12.978c0-0.696-0.093-0.92-0.257-1.085L37.607,0.257C37.442,0.093,37.218,0,36.985,0z\"/>\n                <polygon fill=\"#D9D7CA\" points=\"37.5,0.151 37.5,12 49.349,12 \t\"/>\n                <path fill=\"#9777A8\" d=\"M48.037,56H7.963C7.155,56,6.5,55.345,6.5,54.537V39h43v15.537C49.5,55.345,48.845,56,48.037,56z\"/>\n                <path fill=\"#FFFFFF\" d={'M17.021,42.719v7.848c0,0.474-0.087,0.873-0.26,1.196s-0.405,0.583-0.697,0.779 s-0.627,0.333-1.005,0.41c-0.378,0.077-0.768,0.116-1.169,0.116c-0.2,0-0.436-0.021-0.704-0.062s-0.547-0.104-0.834-0.191 s-0.563-0.185-0.827-0.294s-0.487-0.232-0.67-0.369l0.697-1.107c0.091,0.063,0.221,0.13,0.39,0.198s0.354,0.132,0.554,0.191 s0.41,0.111,0.629,0.157s0.424,0.068,0.615,0.068c0.483,0,0.868-0.094,1.155-0.28s0.439-0.504,0.458-0.95v-7.711H17.021z'}/>\n                <path fill=\"#FFFFFF\" d={'M25.184,50.238c0,0.364-0.075,0.718-0.226,1.06s-0.362,0.643-0.636,0.902s-0.61,0.467-1.012,0.622 s-0.856,0.232-1.367,0.232c-0.219,0-0.444-0.012-0.677-0.034s-0.467-0.062-0.704-0.116c-0.237-0.055-0.463-0.13-0.677-0.226 s-0.398-0.212-0.554-0.349l0.287-1.176c0.128,0.073,0.289,0.144,0.485,0.212s0.398,0.132,0.608,0.191s0.419,0.107,0.629,0.144 s0.405,0.055,0.588,0.055c0.556,0,0.982-0.13,1.278-0.39s0.444-0.645,0.444-1.155c0-0.31-0.104-0.574-0.314-0.793 s-0.472-0.417-0.786-0.595s-0.654-0.355-1.019-0.533s-0.706-0.388-1.025-0.629s-0.583-0.526-0.793-0.854s-0.314-0.738-0.314-1.23 c0-0.446,0.082-0.843,0.246-1.189s0.385-0.641,0.663-0.882s0.602-0.426,0.971-0.554s0.759-0.191,1.169-0.191 c0.419,0,0.843,0.039,1.271,0.116s0.774,0.203,1.039,0.376c-0.055,0.118-0.118,0.248-0.191,0.39s-0.142,0.273-0.205,0.396 s-0.118,0.226-0.164,0.308s-0.073,0.128-0.082,0.137c-0.055-0.027-0.116-0.063-0.185-0.109s-0.166-0.091-0.294-0.137 s-0.296-0.077-0.506-0.096s-0.479-0.014-0.807,0.014c-0.183,0.019-0.355,0.07-0.52,0.157s-0.31,0.193-0.438,0.321 s-0.228,0.271-0.301,0.431s-0.109,0.313-0.109,0.458c0,0.364,0.104,0.658,0.314,0.882s0.47,0.419,0.779,0.588 s0.647,0.333,1.012,0.492s0.704,0.354,1.019,0.581s0.576,0.513,0.786,0.854S25.184,49.7,25.184,50.238z'}/>\n                <path fill=\"#FFFFFF\" d={'M35.082,47.914c0,0.848-0.107,1.595-0.321,2.242s-0.511,1.185-0.889,1.613s-0.82,0.752-1.326,0.971 s-1.06,0.328-1.661,0.328s-1.155-0.109-1.661-0.328s-0.948-0.542-1.326-0.971s-0.675-0.966-0.889-1.613s-0.321-1.395-0.321-2.242 s0.107-1.593,0.321-2.235s0.511-1.178,0.889-1.606s0.82-0.754,1.326-0.978s1.06-0.335,1.661-0.335s1.155,0.111,1.661,0.335 s0.948,0.549,1.326,0.978s0.675,0.964,0.889,1.606S35.082,47.066,35.082,47.914z M30.844,51.729c0.337,0,0.658-0.066,0.964-0.198 s0.579-0.349,0.82-0.649s0.431-0.695,0.567-1.183s0.21-1.082,0.219-1.784c-0.009-0.684-0.08-1.265-0.212-1.743 s-0.314-0.873-0.547-1.183s-0.497-0.533-0.793-0.67s-0.608-0.205-0.937-0.205c-0.337,0-0.658,0.063-0.964,0.191 s-0.579,0.344-0.82,0.649s-0.431,0.699-0.567,1.183c-0.137,0.483-0.21,1.075-0.219,1.777c0.009,0.684,0.08,1.267,0.212,1.75 s0.314,0.877,0.547,1.183s0.497,0.528,0.793,0.67S30.516,51.729,30.844,51.729z'}/>\n                <path fill=\"#FFFFFF\" d=\"M44.68,42.924V53h-1.668l-3.951-6.945V53h-1.668V42.924h1.668l3.951,6.945v-6.945H44.68z\"/>\n                <path fill=\"#9777A8\" d=\"M19.5,19v-4c0-0.551,0.448-1,1-1c0.553,0,1-0.448,1-1s-0.447-1-1-1c-1.654,0-3,1.346-3,3v4 c0,1.103-0.897,2-2,2c-0.553,0-1,0.448-1,1s0.447,1,1,1c1.103,0,2,0.897,2,2v4c0,1.654,1.346,3,3,3c0.553,0,1-0.448,1-1 s-0.447-1-1-1c-0.552,0-1-0.449-1-1v-4c0-1.2-0.542-2.266-1.382-3C18.958,21.266,19.5,20.2,19.5,19z\"/>\n                <circle fill=\"#9777A8\" cx=\"27.5\" cy=\"18.5\" r=\"1.5\"/>\n                <path fill=\"#9777A8\" d=\"M39.5,21c-1.103,0-2-0.897-2-2v-4c0-1.654-1.346-3-3-3c-0.553,0-1,0.448-1,1s0.447,1,1,1 c0.552,0,1,0.449,1,1v4c0,1.2,0.542,2.266,1.382,3c-0.84,0.734-1.382,1.8-1.382,3v4c0,0.551-0.448,1-1,1c-0.553,0-1,0.448-1,1 s0.447,1,1,1c1.654,0,3-1.346,3-3v-4c0-1.103,0.897-2,2-2c0.553,0,1-0.448,1-1S40.053,21,39.5,21z\"/>\n                <path fill=\"#9777A8\" d=\"M27.5,24c-0.553,0-1,0.448-1,1v3c0,0.552,0.447,1,1,1s1-0.448,1-1v-3 C28.5,24.448,28.053,24,27.5,24z\"/>\n            </svg>\n        );\n    }\n}\nexport default JSONFileIcon;\n","import Importer from 'util/file/import/Importer.js';\n\nclass SessionImporter extends Importer\n{\n    constructor(app)\n    {\n        super();\n\n        this._app = app;\n    }\n\n    onParseSession(session, fileData)\n    {\n        return fileData;\n    }\n\n    onPreImportSession(session)\n    {\n        session.getApp().getUndoManager().captureEvent();\n    }\n\n    onImportSession(session, sessionData)\n    {\n        \n    }\n\n    onPostImportSession(session)\n    {\n        session.getApp().getUndoManager().captureEvent();\n    }\n\n    /** @override */\n    importFileData(fileName, fileType, fileData)\n    {\n        const app = this._app;\n        const session = app.getSession();\n        const currentModule = session.getCurrentModule();\n        const result = this.onParseSession(session, fileData);\n\n        this.onPreImportSession(session);\n\n        this.onImportSession(session, result);\n\n        let projectName;\n        if (fileName)\n        {\n            projectName = fileName.substring(0, fileName.length - fileType.length);\n        }\n        else\n        {\n            projectName = result['_metadata']['name'];\n        }\n        \n        app.getSession().setProjectName(projectName);\n\n        this.onPostImportSession(session);\n\n        return currentModule;\n    }\n}\n\nexport default SessionImporter;\n","class Importer\n{\n    constructor() {}\n\n    /**\n     * Try to import the target file. Assumes that isValidFile() returns true.\n     * \n     * @param {String} fileName the name of the target file\n     * @param {String} fileType the associated file extension\n     * @param {String} fileData the file content to import\n     * @returns {Promise} a Promise that resolves if imported without errors\n     */\n    importFileData(fileName, fileType, fileData)\n    {\n        return Promise.resolve(fileData);\n    }\n    \n    getDataType() { return 'text'; }\n}\nexport default Importer;\n","import NodeGraph from 'graph2/NodeGraph.js';\n\n/**\n * A class that represents a node graph with indexed and ordered node list.\n * This means that there exists a first node, which would be used for the\n * start node, if that semantically makes sense for your graph.\n */\nclass IndexedNodeGraph extends NodeGraph\n{\n    /**\n     * Create an IndexedNodeGraph with the respective node and edge classes.\n     * @param {Class} [nodeClass]\n     * @param {Class} [edgeClass]\n     */\n    constructor(nodeClass, edgeClass)\n    {\n        super(nodeClass, edgeClass);\n\n        this._nodes = [];\n    }\n\n    /**\n     * Sets the first node, which is at index 0, to the passed-in node. The node must\n     * already exist in the graph.\n     * @param {GraphNode} node the node to be first\n     */\n    setStartNode(node)\n    {\n        if (this._nodes.length <= 0) throw new Error('Cannot set start node to empty graph');\n\n        // There is only one node, and that is already the start node\n        if (this._nodes.length === 1) return;\n\n        const i = this._nodes.indexOf(node);\n        if (i > 0)\n        {\n            // This does a swap; we could do a prepend but that's more costly...\n            const prev = this._nodes[0];\n            this._nodes[0] = node;\n            this._nodes[i] = prev;\n        }\n        else if (i < 0)\n        {\n            throw new Error('Cannot set start node for unknown node');\n        }\n    }\n\n    /**\n     * Gets the first node, which is at index 0, for the graph.\n     */\n    getStartNode() { return this._nodes.length > 0 ? this._nodes[0] : null; }\n\n    /**\n     * Gets the node by its index. The index must be between 0 and the node count.\n     * @param {Number} index \n     */\n    getNodeByIndex(index)\n    {\n        return this._nodes[index];\n    }\n\n    /** @override */\n    addNode(node)\n    {\n        this._nodes.push(node);\n        return super.addNode(node);\n    }\n\n    /** @override */\n    deleteNode(node)\n    {\n        super.deleteNode(node);\n        const i = this._nodes.indexOf(node);\n        if (i >= 0) this._nodes.splice(i, 1);\n    }\n\n    /** @override */\n    clearNodes()\n    {\n        super.clearNodes();\n        this._nodes.length = 0;\n    }\n\n    /** @override */\n    getNodes()\n    {\n        return this._nodes;\n    }\n}\n\nexport default IndexedNodeGraph;\n","export const FILE_TYPE_PNG = 'png';\nexport const FILE_TYPE_JPG = 'jpg';\nexport const FILE_TYPE_SVG = 'svg';\n\nexport function downloadText(filename, textData)\n{\n    downloadURL(filename, getTextDataURI(textData));\n}\n\nfunction createBlobFromSVG(svg)\n{\n    const serializer = new XMLSerializer();\n    const svgString = serializer.serializeToString(svg);\n    const blob = new Blob([svgString], { type: 'image/svg+xml' });\n    return blob;\n}\n\nexport function downloadImageFromSVG(filename, filetype, svg, width, height)\n{\n    const blob = createBlobFromSVG(svg);\n    switch (filetype)\n    {\n    case FILE_TYPE_PNG:\n    case FILE_TYPE_JPG:\n        {\n            const url = URL.createObjectURL(blob);\n\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            const pixelRatio = window.devicePixelRatio || 1;\n            canvas.width = width * pixelRatio;\n            canvas.height = height * pixelRatio;\n            canvas.style.width = width + 'px';\n            canvas.style.height = height + 'px';\n            ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\n            const image = new Image();\n            image.onload = () => \n            {\n                ctx.drawImage(image, 0, 0);\n                URL.revokeObjectURL(url);\n\n                const imageURI = canvas.toDataURL('image/' + filetype).replace('image/' + filetype, 'image/octet-stream');\n                downloadURL(filename + '.' + filetype, imageURI);\n            };\n            image.src = url;\n        }\n        break;\n    case FILE_TYPE_SVG:\n        {\n            const reader = new FileReader();\n            reader.onload = () => \n            {\n                downloadURL(filename + '.' + filetype, reader.result);\n            };\n            reader.readAsDataURL(blob);\n        }\n        break;\n    default:\n        throw new Error('Unknown file type \\'' + filetype + '\\'');\n    }\n}\n\nexport function downloadURL(filename, url)\n{\n    const element = document.createElement('a');\n    const headerIndex = url.indexOf(';');\n    url = url.substring(0, headerIndex + 1) + 'headers=Content-Disposition%3A%20attachment%3B%20filename=' + filename + ';' + url.substring(headerIndex + 1);\n    element.setAttribute('href', url);\n    element.setAttribute('download', filename);\n\n    element.style.display = 'none';\n    document.body.appendChild(element);\n\n    element.click();\n    document.body.removeChild(element);\n}\n\nfunction getTextDataURI(data)\n{\n    return 'data:text/plain; charset=utf-8,' + encodeURIComponent(data);\n}\n","import React from 'react';\n\nclass PageContentIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n                <path d=\"M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z\"/>\n            </svg>\n        );\n    }\n}\nexport default PageContentIcon;\n","import React from 'react';\n\nclass AddIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z\"/>\n            </svg>\n        );\n    }\n}\nexport default AddIcon;\n","import React from 'react';\n\nclass SubtractIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n                <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z\"/>\n            </svg>\n        );\n    }\n}\nexport default SubtractIcon;\n","import React from 'react';\n\nclass CheckCircleIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n                <path d=\"M16.59 7.58L10 14.17l-3.59-3.58L5 12l5 5 8-8zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z\"/>\n            </svg>\n        );\n    }\n}\nexport default CheckCircleIcon;\n","import React from 'react';\n\nclass CrossCircleIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n                <path d=\"M14.59 8L12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41 14.59 8zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"/>\n            </svg>\n        );\n    }\n}\nexport default CrossCircleIcon;\n","import React from 'react';\n\nclass PendingIcon extends React.PureComponent\n{\n    constructor(props) { super(props); }\n\n    /** @override */\n    render()\n    {\n        return (\n            <svg id={this.props.id} className={this.props.className} style={this.props.style}\n                xmlns=\"http://www.w3.org/2000/svg\"\n                width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n                <path d=\"M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z\"/>\n            </svg>\n        );\n    }\n}\nexport default PendingIcon;\n","const MAX_COMPUTATION_STEPS = 1000;\n\nexport function solveFSA(fsa, input)\n{\n    if (typeof input === 'string') input = input[Symbol.iterator]();\n\n    if (fsa.isDeterministic())\n    {\n        //Solve if the DFA way...\n        let state = fsa.getStartState();\n        let symbol = null;\n\n        //Is testing null after assignment\n        while ((symbol = input.next().value))\n        {\n            const states = fsa.doTransition(state, symbol);\n            if (states.length < 1) return false;\n            //DFA's should only return 1 output\n            state = states[0];\n        }\n        return fsa.isFinalState(state);\n    }\n    else\n    {\n        //Solve it the NFA way...\n        const cachedStates = [];\n        const cachedSymbols = [];\n\n        //Start with the start state...\n        const startState = fsa.getStartState();\n        //(index refers to the \"level\" of computation)\n        cachedStates.push({ state: startState, index: 0 });\n        //...and any state defined similarly by closure...\n        for (const relatedState of fsa.doClosureTransition(startState))\n        {\n            cachedStates.push({ state: relatedState, index: 0 });\n        }\n\n        //The next symbol to compute...\n        let symbol = null;\n\n        //Just to be safe from infinite loops...\n        let counter = 0;\n        while (cachedStates.length > 0)\n        {\n            symbol = input.next().value;\n            if (solveFSAByStep(fsa, symbol, cachedStates, cachedSymbols))\n            {\n                return true;\n            }\n\n            //HACK: This is to stop any infinite loops! This should be fixed in the future!\n            ++counter;\n            if (counter > MAX_COMPUTATION_STEPS)\n            {\n                return false;\n            }\n        }\n\n        return false;\n    }\n}\n\n//TODO: When an empty transition occurs, it does a closure transition.\n//The closure chain will be stored as a group\n//Any future transitions must not re-enter the group\nexport function solveFSAByStep(nfa, symbol, cachedStates, cachedSymbols)\n{\n    //initialize variables\n    let state = null;\n    let nextStates = [];\n    let nextIndex = 0;\n\n    if (symbol)\n    {\n        cachedSymbols.push(symbol);\n    }\n\n    for (const cstate of cachedStates)\n    {\n        state = cstate.state;\n        symbol = cstate.index < cachedSymbols.length ? cachedSymbols[cstate.index] : null;\n\n        if (symbol)\n        {\n            //Read to next state...\n            nextIndex = cstate.index + 1;\n            for (const nextState of nfa.doTerminalTransition(state, symbol))\n            {\n                nextStates.push({ state: nextState, index: nextIndex });\n            }\n        }\n        else\n        {\n            if (nfa.isFinalState(state)) return true;\n        }\n\n        //Read none to next state...\n        nextIndex = cstate.index;\n    }\n    cachedStates.length = 0;\n    cachedStates.push(...nextStates);\n    return false;\n}\n","export {convertToDFA, convertToNFA} from './util/ConvertFSA.js';\nexport {solveFSA, solveFSAByStep} from './util/SolveFSA.js';\nexport { isEquivalentFSAWithWitness, isEquivalentFSA, isEquivalentDFA} from './util/EqualFSA.js';\nexport {invertDFA} from './util/InvertDFA.js';\nexport {intersectFSA, intersectDFA} from './util/IntersectFSA.js';\n","import GraphNode from 'graph2/element/GraphNode.js';\n\nclass FSANode extends GraphNode\n{\n    constructor(id, x, y)\n    {\n        super(id, x, y);\n\n        this._accept = false;\n\n        //this is not saved to hash since it is an aesthetic option\n        this._custom = false;\n    }\n\n    setNodeAccept(value)\n    {\n        this._accept = value;\n    }\n\n    getNodeAccept()\n    {\n        return this._accept;\n    }\n\n    setNodeCustom(value)\n    {\n        this._custom = value;\n    }\n\n    getNodeCustom()\n    {\n        return this._custom;\n    }\n\n    /** @override */\n    getHashString(usePosition = true)\n    {\n        return super.getHashString(usePosition) + ':' + (this._accept ? '1' : '0');\n    }\n}\n\nexport default FSANode;\n","import FSAGraph from './graph/FSAGraph.js';\nimport { SYMBOL_SEPARATOR } from './graph/element/FSAEdge.js';\n\nconst GRAPH_PARSER_VERSION = '1.0.0';\n\nexport const JSON = {\n    parse(data, dst = null)\n    {\n        if (!dst) dst = new FSAGraph();\n        else dst.clear();\n\n        const nodeDatas = data['nodes'] || [];\n        const nodeCount = Math.min(nodeDatas.length || 0, data['nodeCount'] || 0);\n        const edgeDatas = data['edges'] || [];\n        const edgeCount = Math.min(edgeDatas.length || 0, data['edgeCount'] || 0);\n        const initialIndex = data['initial'] || 0;\n\n        const nodeIndices = new Map();\n        for (let i = 0; i < nodeCount; ++i)\n        {\n            const nodeData = nodeDatas[i];\n            if (!nodeData) continue;\n\n            //NOTE: Assumes createNode will maintain order\n            const node = dst.createNode(nodeData['x'] || 0, nodeData['y'] || 0, nodeData['id']);\n            node.setNodeLabel(nodeData['label'] || '');\n            node.setNodeAccept(nodeData['accept'] || false);\n            node.setNodeCustom(nodeData['custom'] || false);\n\n            nodeIndices.set(i, node);\n        }\n\n        const initialNode = nodeIndices.get(initialIndex);\n        if (initialNode)\n        {\n            dst.setStartNode(initialNode);\n        }\n\n        for (let i = 0; i < edgeCount; ++i)\n        {\n            const edgeData = edgeDatas[i];\n            if (!edgeData) continue;\n            const sourceNode = nodeIndices.get(edgeData['from']) || null;\n            //Cannot create source-less edges\n            if (!sourceNode) continue;\n            const destinationNode = nodeIndices.get(edgeData['to']) || null;\n            //NOTE: Assumes createEdge will maintain order\n            const edge = dst.createEdge(sourceNode, destinationNode, edgeData['id']);\n            const quadData = edgeData['quad'] || {};\n            edge.setEdgeLabel(edgeData['label'] || '');\n            edge.setQuadraticRadians(quadData['radians'] || 0);\n            edge.setQuadraticLength(quadData['length'] || 0);\n        }\n\n        return dst;\n    },\n    objectify(graph)\n    {\n        const graphNodes = graph.getNodes() || [];\n        const nodeCount = graphNodes.length || 0;\n        const graphEdges = graph.getEdges() || [];\n        const edgeCount = graphEdges.length || 0;\n        const graphInitial = graph.getStartNode();\n\n        const nodeDatas = new Array(nodeCount);\n        const nodeIndices = new Map();\n        for (let i = 0; i < nodeCount; ++i)\n        {\n            const node = graphNodes[i];\n            if (node)\n            {\n                //NOTE: Assumes node must have an id\n                const elementID = node.getGraphElementID();\n\n                nodeIndices.set(node, i);\n                nodeDatas[i] = {\n                    id: elementID,\n                    x: node.x || 0, y: node.y || 0,\n                    label: node.getNodeLabel() || '',\n                    accept: node.getNodeAccept() || false,\n                    custom: node.getNodeCustom() || false\n                };\n            }\n        }\n\n        const edgeDatas = new Array(edgeCount);\n        for (let i = 0; i < edgeCount; ++i)\n        {\n            const edge = graphEdges[i];\n            if (edge)\n            {\n                //NOTE: Assumes edge must have an id\n                const elementID = edge.getGraphElementID();\n\n                const quad = edge.getQuadratic() || {};\n                const edgeSource = edge.getEdgeFrom();\n                const edgeDestination = edge.getEdgeTo();\n                const sourceIndex = nodeIndices.has(edgeSource) ? nodeIndices.get(edgeSource) : -1;\n                const destinationIndex = nodeIndices.has(edgeDestination) ? nodeIndices.get(edgeDestination) : -1;\n                edgeDatas[i] = {\n                    id: elementID,\n                    from: sourceIndex,\n                    to: destinationIndex,\n                    quad: { radians: quad['radians'] || 0, length: quad['length'] || 0 },\n                    label: edge.getEdgeLabel() || ''\n                };\n            }\n        }\n\n        const initialIndex = nodeIndices.get(graphInitial) || 0;\n\n        return {\n            nodeCount: nodeCount,\n            nodes: nodeDatas,\n            edgeCount: edgeCount,\n            edges: edgeDatas,\n            initial: initialIndex,\n            _version: GRAPH_PARSER_VERSION\n        };\n    }\n};\n\nexport const XML = {\n    parse(data, dst = null)\n    {\n        if (!dst) dst = new FSAGraph();\n        else dst.clear();\n\n        const nodeElements = data.getElementsByTagName('state') || [];\n        const nodeCount = nodeElements.length;\n        const edgeElements = data.getElementsByTagName('transition') || [];\n        const edgeCount = edgeElements.length;\n        let initialIndex = '0';\n\n        //Get the nodes...\n        const nodeElementIDs = new Map();\n        for (let i = 0; i < nodeCount; ++i)\n        {\n            const nodeElement = nodeElements[i];\n            if (!nodeElement) continue;\n            const nodeElementID = nodeElement.getAttribute('id');\n            if (!nodeElementID) continue;\n\n            //Get x value\n            let x = 0;\n            const xElements = nodeElement.getElementsByTagName('x');\n            //If no elements exists, we are guaranteed an empty list...\n            if (xElements.length > 0)\n            {\n                const xElement = xElements[0];\n                if (xElement.hasChildNodes())\n                {\n                    //hasChildNodes() guarantees at least 1 element\n                    const xValue = xElement.childNodes[0];\n                    if (xValue)\n                    {\n                        try\n                        {\n                            x = parseFloat(xValue.nodeValue) || 0;\n                        }\n                        catch (e)\n                        {\n                            x = 0;\n                        }\n                    }\n                }\n            }\n\n            //Get y value\n            let y = 0;\n            const yElements = nodeElement.getElementsByTagName('y');\n            //If no elements exists, we are guaranteed an empty list...\n            if (yElements.length > 0)\n            {\n                const yElement = yElements[0];\n                if (yElement.hasChildNodes())\n                {\n                    //hasChildNodes() guarantees at least 1 element\n                    const yValue = yElement.childNodes[0];\n                    if (yValue)\n                    {\n                        try\n                        {\n                            y = parseFloat(yValue.nodeValue) || 0;\n                        }\n                        catch (e)\n                        {\n                            y = 0;\n                        }\n                    }\n                }\n            }\n\n            //Get initial flag\n            const initialElements = nodeElement.getElementsByTagName('initial');\n            //If no elements exists, we are guaranteed an empty list...\n            const initial = initialElements.length > 0;\n\n            //Get final flag\n            const finalElements = nodeElement.getElementsByTagName('final');\n            //If no elements exists, we are guaranteed an empty list...\n            const final = finalElements.length > 0;\n\n            //NOTE: Assumes createNode will maintain order\n            const node = dst.createNode(x, y);\n            node.setNodeLabel(nodeElement.getAttribute('name') || '');\n            node.setNodeAccept(final);\n\n            if (initial) initialIndex = nodeElementID;\n            nodeElementIDs.set(nodeElementID, node);\n        }\n\n        //Set the initial node...\n        const initialNode = nodeElementIDs.get(initialIndex);\n        if (initialNode)\n        {\n            dst.setStartNode(initialNode);\n        }\n\n        //Readjust the center of graph...\n        const boundingRect = dst.getBoundingRect();\n        const minX = boundingRect.minX;\n        const minY = boundingRect.minY;\n        const width = boundingRect.width;\n        const height = boundingRect.height;\n        const graphNodes = dst.getNodes();\n        for (let i = 0, len = graphNodes.length; i < len; ++i)\n        {\n            graphNodes[i].x -= minX + width / 2;\n            graphNodes[i].y -= minY + height / 2;\n        }\n\n        //Get the transitions...\n        const transitionMapping = new Map();\n        for (let i = 0; i < edgeCount; ++i)\n        {\n            const edgeElement = edgeElements[i];\n            if (!edgeElement) continue;\n\n            //Get from value\n            let sourceID = null;\n            const fromElements = edgeElement.getElementsByTagName('from');\n            //If no elements exists, we are guaranteed an empty list...\n            if (fromElements.length > 0)\n            {\n                const fromElement = fromElements[0];\n                if (fromElement.hasChildNodes())\n                {\n                    //hasChildNodes() guarantees at least 1 element\n                    const fromValue = fromElement.childNodes[0];\n                    if (fromValue)\n                    {\n                        sourceID = fromValue.nodeValue;\n                    }\n                }\n            }\n\n            //Cannot create source-less edges\n            if (!nodeElementIDs.has(sourceID)) continue;\n\n            //Get to value\n            let destinationID = '';\n            const toElements = edgeElement.getElementsByTagName('to');\n            //If no elements exists, we are guaranteed an empty list...\n            if (toElements.length > 0)\n            {\n                const toElement = toElements[0];\n                if (toElement.hasChildNodes())\n                {\n                    //hasChildNodes() guarantees at least 1 element\n                    const toValue = toElement.childNodes[0];\n                    if (toValue)\n                    {\n                        destinationID = toValue.nodeValue || '';\n                    }\n                }\n            }\n\n            //Get read value\n            let symbol = '';\n            const readElements = edgeElement.getElementsByTagName('read');\n            //If no elements exists, we are guaranteed an empty list...\n            if (readElements.length > 0)\n            {\n                const readElement = readElements[0];\n                if (readElement.hasChildNodes())\n                {\n                    //hasChildNodes() guarantees at least 1 element\n                    const readValue = readElement.childNodes[0];\n                    if (readValue)\n                    {\n                        symbol = readValue.nodeValue || '';\n                    }\n                }\n            }\n\n            const transitionID = sourceID + '\\n' + destinationID;\n            let symbols;\n            if (transitionMapping.has(transitionID))\n            {\n                symbols = transitionMapping.get(transitionID);\n            }\n            else\n            {\n                symbols = [];\n                transitionMapping.set(transitionID, symbols);\n            }\n            symbols.push(symbol);\n        }\n\n        for (const transitionKey of transitionMapping.keys())\n        {\n            const key = transitionKey.split('\\n');\n            if (key.length !== 2) continue;\n\n            const symbols = transitionMapping.get(transitionKey);\n            const label = symbols.join(SYMBOL_SEPARATOR);\n            //Should never be null, since it was checked before...\n            const sourceNode = nodeElementIDs.get(key[0]);\n            const destinationNode = nodeElementIDs.get(key[1]);\n\n            //NOTE: Assumes createEdge will maintain order\n            const edge = dst.createEdge(sourceNode, destinationNode);\n            edge.setEdgeLabel(label);\n        }\n\n        return dst;\n    },\n    objectify(graph)\n    {\n        const graphNodes = graph.getNodes() || [];\n        const nodeCount = graphNodes.length || 0;\n        const graphEdges = graph.getEdges() || [];\n        // const edgeCount = graphEdges.length || 0;\n        const graphInitial = graph.getStartNode();\n\n        const header = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>' +\n            '<!--Created with flap.js ' + GRAPH_PARSER_VERSION + '-->' +\n            '<structure></structure>';\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(header, 'application/xml');\n        const structure = doc.getElementsByTagName('structure')[0];\n\n        const type = doc.createElement('type');\n        type.innerHTML = 'fa'; //finite automata\n        structure.appendChild(type);\n\n        const automaton = doc.createElement('automaton');\n        structure.appendChild(automaton);\n\n        const nodeIndices = new Map();\n        for (let i = 0; i < nodeCount; ++i)\n        {\n            const node = graphNodes[i];\n            nodeIndices.set(node, i);\n\n            //state tag\n            const state = doc.createElement('state');\n            state.id = '' + i;\n            state.setAttribute('name', node.getNodeLabel());\n            automaton.appendChild(state);\n\n            //x tag\n            const x = doc.createElement('x');\n            x.innerHTML = '' + (node.x || 0);\n            state.appendChild(x);\n\n            //y tag\n            const y = doc.createElement('y');\n            y.innerHTML = '' + (node.y || 0);\n            state.appendChild(y);\n\n            //initial tag\n            if (graphInitial === node)\n            {\n                state.appendChild(doc.createElement('initial'));\n            }\n\n            //final tag\n            if (node.getNodeAccept())\n            {\n                state.appendChild(doc.createElement('final'));\n            }\n        }\n\n        for (let edge of graphEdges)\n        {\n            const symbols = edge.getEdgeLabel().split(SYMBOL_SEPARATOR);\n            for (let symbol of symbols)\n            {\n                //transition tag\n                const transition = doc.createElement('transition');\n                automaton.appendChild(transition);\n\n                //from tag\n                const from = doc.createElement('from');\n                from.innerHTML = '' + (nodeIndices.get(edge.getEdgeFrom()) || 0);\n                transition.appendChild(from);\n\n                //to tag\n                const to = doc.createElement('to');\n                to.innerHTML = '' + (nodeIndices.get(edge.getEdgeTo()) || 0);\n                transition.appendChild(to);\n\n                //read tag\n                const read = doc.createElement('read');\n                read.innerHTML = '' + (symbol || '');\n                transition.appendChild(read);\n            }\n        }\n\n        return doc;\n    }\n};\n","import { stringHash } from 'util/MathHelper.js';\n\nexport const EMPTY = '\\u03B5';\nexport const CONCAT = '\\u25E6';\nexport const UNION = '\\u222A';\nexport const KLEENE = '*';\nexport const SIGMA = '\\u03A3';\nexport const EMPTY_SET = '\\u2205';\nexport const PLUS = '\\u207A';\n\nclass RE\n{\n    constructor(expression = '')\n    {\n        this._expression = expression;\n        this._terminals = new Set();\n        this._errors = [];\n    }\n\n    /**\n\t * Performs a shallow copy of the 2 machines. Any changes to a state will be\n\t * reflected in both. However, changes to transitions, alphabet, and final\n\t * states will not propagate.\n\t */\n    copy(re)\n    {\n        //You are already yourself, don't copy nothing.\n        if (re === this) return;\n\n        //Make room for the copy...\n        this.clear();\n\n        this._expression = re._expression;\n\n        //Copy terminals\n        for (const terminal of re._terminals)\n        {\n            this._terminals.add(terminal);\n        }\n\n        //Copy errors\n        for (const error of re._errors)\n        {\n            //WARNING: if the error's store state objects, they need to be redirected to the copies\n            this._errors.push(error);\n        }\n    }\n\n    clear()\n    {\n        this._expression = '';\n        this._terminals.clear();\n        this._errors.length = 0;\n    }\n\n    validate()\n    {\n        //Reset errors\n        this._errors.length = 0;\n\n        try\n        {\n            if (this.isExpressionValid())\n            {\n                return true;\n            }\n        }\n        catch (e)\n        {\n            this._errors.push(e);\n        }\n\n        return false;\n    }\n    isValid()\n    {\n        return this._errors.length == 0;\n    }\n    getErrors()\n    {\n        return this._errors;\n    }\n\n    addTerminal(x)\n    {\n        this._terminals.add(x);\n    }\n    hasTerminal(x)\n    {\n        return this._terminals.has(x);\n    }\n    getTerminals()\n    {\n        return this._terminals;\n    }\n    clearTerminals()\n    {\n        this._terminals.clear();\n    }\n\n    areParenthesisBalanced()\n    {\n        let count = 0;\n        let expression = this.getExpression();\n        for (let i = 0; i < expression.length; i++)\n        {\n            if (expression.charAt(i) == '(')\n                count++;\n            else if (expression.charAt(i) == ')')\n                count--;\n            if (count < 0)\n                return false;\n        }\n        return count == 0;\n    }\n\n    isExpressionValid()\n    {\n        let expression = this.getExpression();\n        if (!expression || expression.length == 0) return true;\n        //throw new Error(\"The expression must be nonempty.\");\n        if (!this.areParenthesisBalanced())\n            throw new Error('The parentheses are unbalanced!');\n        switch (expression.charAt(0))\n        {\n        //Only '(' or a symbol can be the first character\n        case ')':\n        case UNION:\n        case KLEENE:\n        case CONCAT:\n        case PLUS:\n            throw new Error('Operators are poorly formatted.');\n        }\n        for (let i = 1; i < expression.length; i++)\n        {\n            let currChar = expression.charAt(i);\n            let prevChar = expression.charAt(i - 1);\n            switch (currChar)\n            {\n            case UNION:\n            case CONCAT:\n                // UNION and CONCAT can't be the last character\n                if (i == expression.length - 1)\n                    throw new Error('Operators are poorly formatted.');\n            // eslint-disable-next-line no-fallthrough\n            case ')':\n            case KLEENE:\n            case PLUS:\n                // Must be preceded with a symbol\n                if (prevChar == '(' || prevChar == UNION || prevChar == CONCAT)\n                    throw new Error('Operators are poorly formatted.');\n                // Kleene and Plus cannot be applied to empty set\n                if ((currChar == KLEENE || currChar == PLUS) && prevChar == EMPTY_SET)\n                    throw new Error('Empty set can only be part of a union or concatenation');\n                break;\n            }\n        }\n        return true;\n    }\n\n    insertConcatSymbols()\n    {\n        let result = '';\n        let expression = this.getExpression();\n        for (let i = 0; i < expression.length; i++)\n        {\n            let currChar = expression.charAt(i);\n            result += currChar;\n            if (i + 1 < expression.length)\n            {\n                let nextChar = expression.charAt(i + 1);\n                if (currChar != '(' && currChar != UNION && currChar != CONCAT &&\n\t\t\t\t\tnextChar != ')' && nextChar != UNION && nextChar != KLEENE && nextChar != PLUS && nextChar != CONCAT)\n                {\n                    result += CONCAT;\n                }\n            }\n        }\n        this.setExpression(result);\n    }\n\n\n    setExpression(expression)\n    {\n        this._expression = expression;\n        return this;\n    }\n\n    getExpression()\n    {\n        return this._expression;\n    }\n\n    getHashCode()\n    {\n        return stringHash(this._expression);\n    }\n}\n\nexport default RE;\n","import {\n    EMPTY,\n    CONCAT,\n    UNION,\n    KLEENE,\n    SIGMA,\n    EMPTY_SET,\n    PLUS\n} from './RE.js';\n\n/**\n* An Abstract Syntax Tree is used for parsing languages, in this case we use them\n* for parsing regular expressions.\n*/\nclass ASTNode\n{\n    constructor(symbol, isTerminal, parentNode, index)\n    {\n        this._symbol = symbol;\t\t\t\t// Character/String to represent symbol from language\n        this._isTerminal = isTerminal;\t\t// Boolean, true if it is a terminal\n        this._parent = parentNode;\n        this._children = [];\n        this._childrenLimit = 2;\t\t\t// By default, ASTNodes can have up to 2 children(binary operators)\n        this._index = index;\t\t\t\t// Index of the symbol in the original String we are parsing\n    }\n\n    addChild(childNode)\n    {\n        if (this.hasRoomForChildren())\n        {\n            this._children.push(childNode);\n            this._isTerminal = false;\n        }\n        else\n        {\n            throw new Error('Trying to add more than 2 children to an ASTNode');\n        }\n    }\n\n    replaceChild(originalChild, newChild)\n    {\n        if (this._children.includes(originalChild))\n        {\n            let index = this._children.indexOf(originalChild);\n            this._children[index] = newChild;\n        }\n        else\n        {\n            throw new Error('The child to replace isn\\'t a child already');\n        }\n    }\n\n    hasRoomForChildren()\n    {\n        return this._children.length < this._childrenLimit;\n    }\n\n    getChildrenLimit()\n    {\n        return this._childrenLimit;\n    }\n\n    setChildrenLimit(newChildrenLimit)\n    {\n        this._childrenLimit = newChildrenLimit;\n    }\n\n    isTerminal()\n    {\n        return this._isTerminal;\n    }\n\n    setTerminal(isTerminal)\n    {\n        this._isTerminal = isTerminal;\n    }\n\n    getSymbol()\n    {\n        return this._symbol;\n    }\n\n    setSymbol(newSymbol)\n    {\n        this._symbol = newSymbol;\n    }\n\n    getParent()\n    {\n        return this._parent;\n    }\n\n    setParent(parentNode)\n    {\n        this._parent = parentNode;\n    }\n\n    getChildren()\n    {\n        return this._children;\n    }\n\n    getIndex()\n    {\n        return this._index;\n    }\n\n    setIndex(index)\n    {\n        this._index = index;\n    }\n}\n\nclass REParser\n{\n    constructor()\n    {\n        this.rootNode = null;\n        this.size = 0;\n        this.indexToNode = new Map();\t// Map of indicies of the regex characters to their ASTNode\n        this.closedParensIndicies = [];\t\t\t// Indicies of the closed parenthesis in the regex\n    }\n\n    parseRegex(regex)\n    {\n        this.rootNode = null;\n        this.size = 0;\n        regex.clearTerminals();\n        if (regex.getExpression().length == 0)\n        {\n            regex.clear();\n            return;\n        }\n        else if (regex.isExpressionValid())\n        {\n            let currNode = this.rootNode;\n            let openParenStack = [];\n            let expression = regex.getExpression();\n            let index = -1;\n\n            for (const char of expression)\n            {\n                this.size = this.size + 1;\n                index++;\n                switch (char)\n                {\n                case '(':\n                    currNode = this.createOpenParenNode(currNode, index);\n                    openParenStack.push(currNode);\n                    break;\n                case ')':\n                    currNode = openParenStack.pop();\n                    this.closedParensIndicies.push(index);\n                    break;\n                case KLEENE:\n                    currNode = this.createUnaryOperNode(currNode, index, KLEENE);\n                    break;\n                case PLUS:\n                    currNode = this.createUnaryOperNode(currNode, index, PLUS);\n                    break;\n                case CONCAT:\n                    currNode = this.createBinaryOperNode(currNode, index, CONCAT);\n                    break;\n                case UNION:\n                    currNode = this.createBinaryOperNode(currNode, index, UNION);\n                    break;\n                    //Ignore spaces\n                case ' ':\n                    break;\n                    //For symbols\n                default:\n                {\n                    currNode = this.createTerminalNode(currNode, index, char);\n                    // Add TERMINALS ONLY to the regex's terminal set\n                    if (char != SIGMA && char != EMPTY_SET && char != EMPTY)\n                    {\n                        regex.addTerminal(char);\n                    }\n                }\n                }\n            }\n        }\n    }\n\n    makeParentOf(newParentNode, targetNode)\n    {\n        let originalParent = targetNode.getParent();\n        newParentNode.setParent(originalParent);\n        newParentNode.addChild(targetNode);\n        if (originalParent != null)\n        {\n            originalParent.replaceChild(targetNode, newParentNode);\n        }\n        targetNode.setParent(newParentNode);\n\n        if (this.rootNode == targetNode)\n        {\n            this.rootNode = newParentNode;\n        }\n    }\n\n    createOpenParenNode(currNode, index)\n    {\n        if (!currNode)\n        {\n            currNode = new ASTNode('(', false, null, index);\n            this.indexToNode.set(index, currNode);\n            this.rootNode = currNode;\n        }\n        else\n        {\n            let newNode = new ASTNode('(', false, currNode, index);\n            this.indexToNode.set(index, newNode);\n            currNode.addChild(newNode);\n            currNode = newNode;\n        }\n        return currNode;\n    }\n\n    createUnaryOperNode(currNode, index, symbol)\n    {\n        let newNode = new ASTNode(symbol, false, currNode.getParent(), index);\n        this.indexToNode.set(index, newNode);\n        this.makeParentOf(newNode, currNode);\n        currNode = newNode;\n        return currNode;\n    }\n\n    createBinaryOperNode(currNode, index, symbol)\n    {\n        if(!currNode.getParent())\n        {\n            let newNode = new ASTNode(symbol, false, null, index);\n            this.indexToNode.set(index, newNode);\n            this.makeParentOf(newNode, currNode);\n            currNode = newNode;\n        }\n        else\n        {\n            //Special cases where the newly created node should be the parent of\n            //the PARENT of the currNode are based off of symbol, so whenever\n            //we add a new binary operator, this is something you should MODIFY\n            let makeParentOfParent = 0;\n            const originalParent = currNode.getParent();\n            const parentSym = originalParent.getSymbol();\n            switch(symbol)\n            {\n            case CONCAT:\n                if(parentSym == CONCAT) makeParentOfParent = 1;\n                break;\n            case UNION:\n                if(parentSym != '(') makeParentOfParent = 1;\n                break;\n            }\n            if(makeParentOfParent)\n            {\n                let grandparent = originalParent.getParent();\n                let newNode = new ASTNode(symbol, false, grandparent, index);\n                this.indexToNode.set(index, newNode);\n                this.makeParentOf(newNode, originalParent);\n                currNode = newNode;\n            }\n            else\n            {\n                let newNode = new ASTNode(symbol, false, originalParent, index);\n                this.indexToNode.set(index, newNode);\n                this.makeParentOf(newNode, currNode);\n                currNode = newNode;\n            }\n        }\n        return currNode;\n    }\n\n    createTerminalNode(currNode, index, symbol)\n    {\n        if (!currNode)\n        {\n            currNode = new ASTNode(symbol, true, null, index);\n            this.indexToNode.set(index, currNode);\n            this.rootNode = currNode;\n        }\n        else\n        {\n            let symbolNode = new ASTNode(symbol, true, currNode, index);\n            this.indexToNode.set(index, symbolNode);\n            currNode.addChild(symbolNode);\n            currNode = symbolNode;\n        }\n        return currNode;\n    }\n\n    /**\n\t * @param {Regex}  regex \tThe regular expression to parse and do scope highlighting on\n\t * @param {Number} spaceIndex is the index of the space between the characters in the regex\n\t * E.g.   A U B\n\t *       0 1 2 3\n\t * A cursor can only be clicked on a spaceIndex, hence its use\n\t * @return {Array} [[start1_spaceIndex, end1_spaceIndex], [start2_spaceIndex, end2_spaceIndex]] of the scope\n\t */\n    scopeFromSpaceIndexing(regex, spaceIndex)\n    {\n        if(spaceIndex == 0) \n        {\n            return [[0, 0], [0, 0]];\n        }\n        else if(spaceIndex > 0 && spaceIndex <= this.size + 1) \n        {\n            const index = spaceIndex - 1;\n            const scope = this.scopeFromCharAtIndex(regex, index);\n            // scope will be null if the character selected is just an operand,\n            // so nothing should be highlighted\n            if (!scope) \n            {\n                return [ [spaceIndex, spaceIndex],  [spaceIndex, spaceIndex] ];\n            }\n            else \n            {\n                scope[1][1] += 1;\t//Increment last index to account for space indexing in highlighting\n                return scope;\n            }\n        }\n        else \n        {\n            throw new Error('Invalid index');\n        }\n    }\n\n    /**\n\t * @param {Regex}  regex \tThe regular expression to parse and do scope highlighting on\n\t * @param {Number} index  \tis the index of the characters in the regex\n\t *  Scope in this context is considered as the operands for a selected operator\n\t *\tFor an operand \t-> there is no scope, return null\n\t *  For a unary operator -> return [[start_index, start_index], [end_index, end_index]]\n\t *\t\t\t\t\t\t\tstart_index is index of beginning index of the sole operand and\n\t *\t\t\t\t\t\t\tend_index is the index of the end\n\t * For a binary operator -> return [[start1_index, end1_index], [start2_index, end2_index]]\n\t *\t\t\t\t\t\t\tstart1_index and end1_index correspond to the first operand\n\t *\t\t\t\t\t\t\tstart2_index and end2_index correspond to the second operand\n\t * Finding the start and end indicies relies on the parse tree made, where operands of an\n\t * operator are descendants in the subtree where the operator is the root node, so earliest\n\t * and latest parts of the operands will be the terminal nodes with the least and highest index\n\t * @return {Array} [[start1_spaceIndex, end1_spaceIndex], [start2_spaceIndex, end2_spaceIndex]] of the scope\n\t */\n    scopeFromCharAtIndex(regex, index)\n    {\n        this.parseRegex(regex);\n        let currentNode = this.indexToNode.get(index);\n        let symbol = currentNode.getSymbol();\n        //Unary operators\n        if(symbol == KLEENE || symbol == PLUS) \n        {\n            let smallest = this.smallestIndexOfChildren(currentNode);\n            let largest = this.largestIndexOfChildren(currentNode);\n            return [ [smallest, smallest], [largest, largest] ];\n        }\n        //Binary operators\n        else if(symbol == UNION || symbol == CONCAT) \n        {\n            let smallest = this.smallestIndexOfChildren(currentNode);\n            let largest = this.largestIndexOfChildren(currentNode);\n            return [ [smallest, index - 1], [index + 1, largest] ];\n        }\n        //Operands\n        else \n        {\n            return null;\n        }\n    }\n\n    // Return child with the largest index\n    largestIndexOfChildren(node)\n    {\n        let max = node.getIndex();\n        for (let child of node.getChildren()) \n        {\n            max = Math.max(max, this.largestIndexOfChildren(child));\n        }\n        return max;\n    }\n\n    // Return child with the smallest index\n    smallestIndexOfChildren(node)\n    {\n        let min = node.getIndex();\n        for (let child of node.getChildren()) \n        {\n            min = Math.min(min, this.smallestIndexOfChildren(child));\n        }\n        return min;\n    }\n\n}\n\nexport default REParser;\n","import FSA, { EMPTY_SYMBOL } from 'modules/fsa2/machine/FSA.js';\nimport\n{\n    EMPTY,\n    CONCAT,\n    UNION,\n    KLEENE,\n    SIGMA,\n    EMPTY_SET,\n    PLUS\n} from '../RE.js';\n\nimport REParser from '../REParser.js';\n\n// Return NFA representation of the input regular expression\n// Construction of NFA is done using Thompson's algorithm\nexport function convertToNFA(re)\n{\n    const prevExpression = re.getExpression();\n    re.setExpression(prevExpression.replace(/\\s/g, ''));\n    re.insertConcatSymbols();\n    const parser = new REParser();\n    parser.parseRegex(re);         //Create parse tree and add terminals to re's terminal set\n    const nfa = ASTtoNFA(parser.rootNode, re);\n    re.setExpression(prevExpression);\n    return nfa;\n}\n\nfunction ASTtoNFA(astNode, re)\n{\n    //Base case, terminal nodes are characters in the alphabet OR\n    //the EmptySet or Sigma\n    if (astNode.isTerminal())\n    {\n        switch (astNode.getSymbol())\n        {\n        case EMPTY_SET:\n            return emptySet();\n        case SIGMA:\n            return sigma(re);\n        default:\n            return character(astNode.getSymbol());\n        }\n    }\n    switch (astNode.getSymbol())\n    {\n    case KLEENE:\n        return kleene(ASTtoNFA(astNode._children[0], re));\n    case PLUS:\n        return plus(ASTtoNFA(astNode._children[0], re));\n    case CONCAT:\n        return concat(ASTtoNFA(astNode._children[0], re), ASTtoNFA(astNode._children[1], re));\n    case UNION:\n        return or(ASTtoNFA(astNode._children[0], re), ASTtoNFA(astNode._children[1], re));\n    case '(':\n        return ASTtoNFA(astNode._children[0], re);\n    default:\n        throw new Error('You\\'ve got a weird node in the AST tree with symbol ' + astNode.getSymbol());\n    }\n}\n\n// For the empty set, the NFA is a start state, with no final state, nor transitions.\nfunction emptySet()\n{\n    const result = new FSA(false);\n    const state0 = result.createState('q0');\n    result.setStartState(state0);\n    return result;\n}\n\n// For Sigma, the NFA is just the union of all the terminals in the regular expression\n// e.g. if Sigma = {0, 1}, then as a regular expression it is just 0 U 1\nfunction sigma(re)\n{\n    const terminals = re.getTerminals();\n    const charNFAs = [];\n\n    if (terminals.size == 0) \n    {\n        return emptySet();\n    }\n    // Build NFAs for each terminal in the terminal set\n    for (const terminal of terminals) \n    {\n        charNFAs.push(character(terminal));\n    }\n    // Unionize them into one big union NFA to return\n    while (charNFAs.length > 1)\n    {\n        charNFAs[0] = or(charNFAs[0], charNFAs[1]);     // Accumulate in the 0th index\n        charNFAs.splice(1, 1);                          // Shift down from 1st index\n    }\n    return charNFAs[0];\n}\n\n// For a symbol of the alphabet, the NFA is two states, a start and a finish state,\n// with the transition being the symbol.\nfunction character(symbol)\n{\n    // Necessary for having empty in an FSA\n    if (symbol == EMPTY) \n    {\n        symbol = EMPTY_SYMBOL;\n    }\n    const result = new FSA(false);\n    const state0 = result.createState('q0');\n    const state1 = result.createState('q1');\n    result.addTransition(state0, state1, symbol);\n    result.setStartState(state0);\n    result.setFinalState(state1);\n    return result;\n}\n\nfunction concat(a, b)\n{\n    const result = new FSA(false);\n    let stateIndex = 0;\n\n    let aStateMap = new Map();\n    let firstAState = null;\n    // let lastAState = null;\n    for (const state of a.getStates())\n    {\n        let newState = result.createState('q' + (stateIndex++));\n        aStateMap.set(state, newState);\n        if (firstAState === null) firstAState = newState;\n        // lastAState = newState;\n    }\n\n    let bStateMap = new Map();\n    let firstBState = null;\n    let lastBState = null;\n    for (const state of b.getStates())\n    {\n        let newState = result.createState('q' + (stateIndex++));\n        bStateMap.set(state, newState);\n        if (firstBState === null) firstBState = newState;\n        // lastBState should only be set to a final state (EMPTY_SET has none)\n        if (b.isFinalState(state)) \n        {\n            lastBState = newState;\n        }\n    }\n\n    const aTransitions = a.getTransitions();\n    for (const transition of aTransitions)\n    {\n        const newFromState = aStateMap.get(transition.getSourceState());\n        const newToState = aStateMap.get(transition.getDestinationState());\n        if (newFromState === null || newToState === null) throw new Error('Unable to find state endpoints for transition');\n        for (const symbol of transition.getSymbols())\n        {\n            result.addTransition(newFromState, newToState, symbol);\n        }\n    }\n\n    for (const finalState of a.getFinalStates())\n    {\n        const newFinalState = aStateMap.get(finalState);\n        result.addTransition(newFinalState, firstBState, EMPTY_SYMBOL);\n    }\n\n    const bTransitions = b.getTransitions();\n    for (const transition of bTransitions)\n    {\n        const newFromState = bStateMap.get(transition.getSourceState());\n        const newToState = bStateMap.get(transition.getDestinationState());\n        if (newFromState === null || newToState === null) throw new Error('Unable to find state endpoints for transition');\n        for (const symbol of transition.getSymbols())\n        {\n            result.addTransition(newFromState, newToState, symbol);\n        }\n    }\n\n    result.setStartState(firstAState);\n    if (lastBState != null) result.setFinalState(lastBState);\n    return result;\n}\n\nfunction kleene(a)\n{\n    const result = new FSA(false);\n    let stateIndex = 0;\n\n    const stateMap = new Map();\n\n    const firstState = result.createState('q' + (stateIndex++));\n    let firstAState = null;\n    let lastAState = null;\n    for (const state of a.getStates())\n    {\n        let newState = result.createState('q' + (stateIndex++));\n        stateMap.set(state, newState);\n\n        if (firstAState === null) firstAState = newState;\n        lastAState = newState;\n    }\n    const lastState = result.createState('q' + (stateIndex++));\n\n    result.addTransition(firstState, firstAState, EMPTY_SYMBOL);\n\n    const aTransitions = a.getTransitions();\n    for (const transition of aTransitions)\n    {\n        const newFromState = stateMap.get(transition.getSourceState());\n        const newToState = stateMap.get(transition.getDestinationState());\n        if (newFromState === null || newToState === null) throw new Error('Unable to find state endpoints for transition');\n        for (const symbol of transition.getSymbols())\n        {\n            result.addTransition(newFromState, newToState, symbol);\n        }\n    }\n\n    result.addTransition(lastAState, lastState, EMPTY_SYMBOL);\n    result.addTransition(lastAState, firstAState, EMPTY_SYMBOL);\n    result.addTransition(firstState, lastState, EMPTY_SYMBOL);\n\n    result.setStartState(firstState);\n    result.setFinalState(lastState);\n    return result;\n}\n\nfunction plus(a)\n{\n    return concat(a, kleene(a));\n}\n\nfunction or(a, b)\n{\n    const result = new FSA(false);\n    let stateIndex = 0;\n\n    const firstState = result.createState('q' + (stateIndex++));\n\n    let aStateMap = new Map();\n    let firstAState = null;\n    let lastAState = null;\n    for (const state of a.getStates())\n    {\n        let newState = result.createState('q' + (stateIndex++));\n        aStateMap.set(state, newState);\n        if (firstAState === null) firstAState = newState;\n        // lastAState should only be set to a final state (EMPTY_SET has none)\n        if (a.isFinalState(state)) \n        {\n            lastAState = newState;\n        }\n    }\n\n    let bStateMap = new Map();\n    let firstBState = null;\n    let lastBState = null;\n    for (const state of b.getStates())\n    {\n        let newState = result.createState('q' + (stateIndex++));\n        bStateMap.set(state, newState);\n        if (firstBState === null) firstBState = newState;\n        // lastBState should only be set to a final state (EMPTY_SET has none)\n        if (b.isFinalState(state)) \n        {\n            lastBState = newState;\n        }\n    }\n\n    const lastState = result.createState('q' + (stateIndex++));\n\n    //A machine\n    result.addTransition(firstState, firstAState, EMPTY_SYMBOL);\n    const aTransitions = a.getTransitions();\n    for (const transition of aTransitions)\n    {\n        const newFromState = aStateMap.get(transition.getSourceState());\n        const newToState = aStateMap.get(transition.getDestinationState());\n        if (newFromState === null || newToState === null) throw new Error('Unable to find state endpoints for transition');\n        for (const symbol of transition.getSymbols())\n        {\n            result.addTransition(newFromState, newToState, symbol);\n        }\n    }\n    if (lastAState != null) \n    {\n        result.addTransition(lastAState, lastState, EMPTY_SYMBOL);\n    }\n\n    //B machine\n    result.addTransition(firstState, firstBState, EMPTY_SYMBOL);\n    const bTransitions = b.getTransitions();\n    for (const transition of bTransitions)\n    {\n        const newFromState = bStateMap.get(transition.getSourceState());\n        const newToState = bStateMap.get(transition.getDestinationState());\n        if (newFromState === null || newToState === null) throw new Error('Unable to find state endpoints for transition');\n        for (const symbol of transition.getSymbols())\n        {\n            result.addTransition(newFromState, newToState, symbol);\n        }\n    }\n    if (lastBState != null) \n    {\n        result.addTransition(lastBState, lastState, EMPTY_SYMBOL);\n    }\n\n    result.setStartState(firstState);\n    result.setFinalState(lastState);\n    return result;\n}\n","import {stringHash} from 'util/MathHelper.js';\n\nclass ExpressionChangeHandler\n{\n    constructor(refreshTicks=10)\n    {\n        this._cachedExpressionHash = 0;\n\n        this._refreshTicks = refreshTicks;\n        this._elapsedTicks = Infinity;\n\n        this._listeners = [];\n    }\n\n    addListener(listener)\n    {\n        if (typeof listener !== 'function')\n            throw new Error('Cannot add uncallable listener');\n        this._listeners.push(listener);\n    }\n\n    removeListener(listener)\n    {\n        const i = this._listeners.indexOf(listener);\n        if (i >= 0)\n        {\n            this._listeners.splice(i, 1);\n            return true;\n        }\n        return false;\n    }\n\n    clearListeners()\n    {\n        this._listeners.length = 0;\n    }\n\n    getListeners()\n    {\n        return this._listeners;\n    }\n\n    reset()\n    {\n        this._elapsedTicks = 0;\n        this._cachedExpressionHash = 0;\n    }\n\n    update(expr)\n    {\n        if (++this._elapsedTicks >= this._refreshTicks)\n        {\n            this._elapsedTicks = 0;\n\n            const exprHash = stringHash(expr);\n            if (exprHash !== this._cachedExpressionHash)\n            {\n                this._cachedExpressionHash = exprHash;\n                for(const listener of this._listeners)\n                {\n                    listener(expr);\n                }\n            }\n        }\n    }\n}\n\nexport default ExpressionChangeHandler;\n","import {stringHash} from 'util/MathHelper.js';\n\nimport RE from './machine/RE.js';\nimport REParser from './machine/REParser.js';\nimport {convertToNFA} from './machine/REUtils.js';\n\nimport ExpressionChangeHandler from './ExpressionChangeHandler.js';\n\nconst EXPRESSION_REFRESH_RATE = 30;\n// const ERROR_MESSAGE_TAG = 're_parse_error';\n\nclass MachineController\n{\n    constructor()\n    {\n        this._machine = new RE();\n        this._parser = new REParser();\n        this._expressionChangeHandler = new ExpressionChangeHandler(EXPRESSION_REFRESH_RATE);\n\n        this._equalFSA = null;\n        this._equalREHash = stringHash(this._machine.getExpression());\n    }\n\n    update()\n    {\n        this._expressionChangeHandler.update(this._machine.getExpression());\n    }\n\n    clear()\n    {\n        this.setMachineExpression('');\n    }\n\n    isSymbol(symbol)\n    {\n        return this._machine.hasTerminal(symbol);\n    }\n\n    isUsedSymbol(symbol)\n    {\n        return this.isSymbol(symbol);\n    }\n\n    renameSymbol(symbol, nextSymbol)\n    {\n        const prevExpression = this._machine.getExpression();\n        const nextExpression = prevExpression.replace(new RegExp(symbol, 'g'), nextSymbol);\n        this.setMachineExpression(nextExpression);\n    }\n\n    deleteSymbol(symbol)\n    {\n        const prevExpression = this._machine.getExpression();\n        const nextExpression = prevExpression.replace(new RegExp(symbol, 'g'), '');\n        this.setMachineExpression(nextExpression);\n    }\n\n    getMachineTerminals()\n    {\n        return Array.from(this._machine.getTerminals());\n    }\n\n    getEquivalentFSA()\n    {\n        if (!this._equalFSA || (stringHash(this._machine.getExpression()) !== this._equalREHash))\n        {\n            this._equalREHash = stringHash(this._machine.getExpression());\n            this._equalFSA = convertToNFA(this._machine);\n        }\n        return this._equalFSA;\n    }\n\n    setMachineExpression(string)\n    {\n        this._machine.setExpression(string);\n        if (this._machine.validate())\n        {\n            this._parser.parseRegex(this._machine);\n        }\n    }\n\n    getMachineExpression()\n    {\n        return this._machine.getExpression() || '';\n    }\n\n    getMachineErrors()\n    {\n        return this._machine.getErrors();\n    }\n\n    getMachine()\n    {\n        return this._machine;\n    }\n\n    getExpressionChangeHandler()\n    {\n        return this._expressionChangeHandler;\n    }\n}\n\nexport default MachineController;\n","import {SUCCESS_LAYOUT_ID, ERROR_LAYOUT_ID} from 'session/manager/notification/NotificationManager.js';\nimport {\n    MACHINE_ERROR_NOTIFICATION_TAG\n} from './components/notifications/RENotifications.js';\n\nclass REErrorChecker\n{\n    constructor(app, machineController)\n    {\n        this._app = app;\n        this._machineController = machineController;\n        this._showErrorOnChange = false;\n\n        this.onExpressionChange = this.onExpressionChange.bind(this);\n\n        machineController.getExpressionChangeHandler().addListener(this.onExpressionChange);\n    }\n\n    onExpressionChange(expression)\n    {\n        if (this._showErrorOnChange)\n        {\n            this.showErrors();\n        }\n    }\n\n    setErrorChecking(enabled)\n    {\n        this._showErrorOnChange = enabled;\n    }\n\n    isErrorChecking()\n    {\n        return this._showErrorOnChange;\n    }\n\n    showErrors()\n    {\n        const errors = this._machineController.getMachine().getErrors();\n\n        const app = this._app;\n        const notificationManager = app.getNotificationManager();\n\n        notificationManager.clearNotifications(MACHINE_ERROR_NOTIFICATION_TAG);\n        if (errors.length <= 0)\n        {\n            notificationManager.pushNotification(\n                I18N.toString('message.error.none'),\n                SUCCESS_LAYOUT_ID, MACHINE_ERROR_NOTIFICATION_TAG, null, false);\n        }\n        else\n        {\n            for(const error of errors)\n            {\n                notificationManager.pushNotification(error.name + ' - ' + error.message,\n                    ERROR_LAYOUT_ID, MACHINE_ERROR_NOTIFICATION_TAG, null, false);\n            }\n        }\n    }\n}\n\nexport default REErrorChecker;\n","export const MACHINE_ERROR_NOTIFICATION_TAG = 'machine-error';\n\nexport function registerNotifications(notificationManager)\n{\n  \n}\n","import AbstractEventHandler from 'session/manager/undo/AbstractEventHandler.js';\n\nclass SafeExpressionEventHandler extends AbstractEventHandler\n{\n    constructor(machineController)\n    {\n        super();\n\n        this._machineController = machineController;\n        this._expression = machineController.getMachineExpression();\n    }\n\n    /** @override */\n    applyUndo(undoManager)\n    {\n        const prevEvent = undoManager.getPreviousEvent();\n        if (prevEvent instanceof SafeExpressionEventHandler)\n        {\n            prevEvent.applyRedo(undoManager);\n        }\n        else\n        {\n            this._machineController.clear();\n        }\n    }\n\n    /** @override */\n    applyRedo(undoManager)\n    {\n        this._machineController.setMachineExpression(this._expression);\n    }\n}\nexport default SafeExpressionEventHandler;\n","import React from 'react';\nimport Style from './AlphabetListElement.css';\n\nconst SUBMIT_KEY_CODE = 'Enter';\nconst CANCEL_KEY_CODE = 'Escape';\n\nclass AlphabetListElement extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n\n        this._inputElement = null;\n\n        this.state = {\n            value: null,\n            error: false\n        };\n\n        this.onValueChange = this.onValueChange.bind(this);\n        this.onFocus = this.onFocus.bind(this);\n        this.onBlur = this.onBlur.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        this.onKeyUp = this.onKeyUp.bind(this);\n    }\n\n    onFocus(e)\n    {\n        const target = e.target;\n        const symbol = this.props.symbol;\n\n        this.setState({\n            value: symbol,\n            error: false\n        }, () => target.select());\n\n        //Call any listening focus\n        if (this.props.onFocus) this.props.onFocus(e, this);\n    }\n\n    onBlur(e)\n    {\n        const nextSymbol = this.state.value;\n\n        //Call any listening blurs\n        if (this.props.onBlur) this.props.onBlur(e, this, nextSymbol);\n\n        //Reset to nothing (will use props.symbol instead)\n        this.setState({ value: null, error: false });\n    }\n\n    onKeyDown(e)\n    {\n        const keyCode = e.key;\n        if (keyCode === SUBMIT_KEY_CODE || keyCode === CANCEL_KEY_CODE)\n        {\n            e.preventDefault();\n            e.stopPropagation();\n        }\n    }\n\n    onKeyUp(e)\n    {\n        const keyCode = e.key;\n        const target = e.target;\n\n        if (keyCode === SUBMIT_KEY_CODE)\n        {\n            target.blur();\n        }\n        else if (keyCode === CANCEL_KEY_CODE)\n        {\n            this.setState({\n                value: null,\n                error: false\n            }, () => target.blur());\n        }\n    }\n\n    onValueChange(e)\n    {\n        let value = e.target.value.trim();\n        let error = false;\n\n        if (this.props.onChange)\n        {\n            try\n            {\n                this.props.onChange(e, this, value);\n            }\n            catch(e)\n            {\n                error = true;\n            }\n        }\n\n        this.setState({\n            value: value,\n            error: error\n        });\n    }\n\n    focus()\n    {\n        this._inputElement.focus();\n    }\n\n    /** @override */\n    render()\n    {\n        const inputSymbol = this.state.value;\n        const displaySymbol = inputSymbol === null ? this.props.symbol : inputSymbol;\n\n        const symbolUsed = this.props.used || false;\n\n        return (\n            <div id={this.props.id}\n                className={Style.element_container +\n          (displaySymbol !== null && displaySymbol.length <= 0 ? ' empty ' : '') +\n          (inputSymbol !== null && this.state.error ? ' error ' : '') +\n          (symbolUsed ? ' used ' : '') +\n          ' ' + this.props.className}\n                style={this.props.style}>\n                <input ref={ref=>this._inputElement=ref}\n                    spellCheck={false}\n                    maxLength={1}\n                    style={{width: '1ch'}}\n                    value={displaySymbol}\n                    onChange={this.onValueChange}\n                    onFocus={this.onFocus}\n                    onBlur={this.onBlur}\n                    onKeyDown={this.onKeyDown}\n                    onKeyUp={this.onKeyUp}/>\n            </div>\n        );\n    }\n}\n\nexport default AlphabetListElement;\n","import React from 'react';\nimport Style from './AlphabetListView.css';\n\nimport AlphabetListElement from './AlphabetListElement.js';\n\nclass TerminalListView extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n\n        this.newSymbolComponent = null;\n\n        this.state = {\n            useNewSymbol: false\n        };\n\n        this.onElementAdd = this.onElementAdd.bind(this);\n        this.onElementFocus = this.onElementFocus.bind(this);\n        this.onElementBlur = this.onElementBlur.bind(this);\n        this.onElementChange = this.onElementChange.bind(this);\n    }\n\n    onElementAdd(e)\n    {\n    //Create a new alphabet element...\n        this.setState({useNewSymbol: true}, () => \n        {\n            this.newSymbolComponent.focus();\n        });\n    }\n\n    onElementFocus(e, element)\n    {\n    //Do nothing...\n    }\n\n    onElementBlur(e, element, nextSymbol)\n    {\n        const symbol = element.props.symbol;\n        const machineController = this.props.machineController;\n\n        if (nextSymbol !== null)\n        {\n            if (nextSymbol.length > 0)\n            {\n                if (!machineController.isSymbol(nextSymbol))\n                {\n                    if (symbol)\n                    {\n                        //None other have the same name. Rename it!\n                        machineController.renameSymbol(symbol, nextSymbol);\n                    }\n                    else\n                    {\n                        //None other have the same name. Create it!\n                        //machineController.createSymbol(nextSymbol);\n                    }\n                }\n                else\n                {\n                    //Found something already named that! Ignore!\n                }\n            }\n            else if (symbol)\n            {\n                //Delete!\n                machineController.deleteSymbol(symbol);\n            }\n        }\n\n        //Regardless, just close the \"new\" alphabet element if open.\n        if (this.state.useNewSymbol)\n        {\n            this.setState({ useNewSymbol: false });\n        }\n    }\n\n    onElementChange(e, element, symbol)\n    {\n        const machineController = this.props.machineController;\n\n        if (symbol.length > 0)\n        {\n            //If there are more than 1 symbols by the same name,\n            //OR if the duplicate symbol found is NOT the same symbol\n            if (machineController.isSymbol(symbol) && symbol !== element.props.symbol)\n            {\n                throw new Error('Not a valid symbol');\n            }\n        }\n    }\n\n    renderTerminalList(machineController, terminals)\n    {\n        const result = [];\n        for(const symbol of terminals)\n        {\n            if (!symbol) continue;\n\n            result.push(<AlphabetListElement key={symbol}\n                symbol={symbol}\n                used={machineController.isUsedSymbol(symbol)}\n                onFocus={this.onElementFocus}\n                onBlur={this.onElementBlur}\n                onChange={this.onElementChange}/>);\n        }\n        return result;\n    }\n\n    /** @override */\n    render()\n    {\n        const machineController = this.props.machineController;\n        const terminals = machineController.getMachineTerminals();\n\n        return (\n            <div id={this.props.id}\n                className={Style.list_container}\n                style={this.props.style}>\n                <div className={Style.element_list}>\n                    {this.renderTerminalList(machineController, terminals)}\n                    <AlphabetListElement\n                        ref={ref=>this.newSymbolComponent=ref}\n                        style={{display: this.state.useNewSymbol ? 'block' : 'none'}}\n                        symbol={''}\n                        onFocus={this.onElementFocus}\n                        onBlur={this.onElementBlur}\n                        onChange={this.onElementChange}/>\n                </div>\n                {/*\n          <IconButton className={Style.add_button}\n            title=\"Add Terminal\"\n            onClick={this.onElementAdd}\n            disabled={true}>\n            <BoxAddIcon/>\n          </IconButton>\n        */}\n            </div>\n        );\n    }\n}\n\nexport default TerminalListView;\n","import React from 'react';\n// import Style from './OverviewPanel.css';\n\nimport PanelContainer from 'experimental/panels/PanelContainer.js';\nimport PanelSection from 'experimental/panels/PanelSection.js';\n\nimport AlphabetListView from './alphabet/AlphabetListView.js';\n\nimport {EMPTY, CONCAT, UNION, KLEENE, SIGMA, EMPTY_SET, PLUS} from 'modules/re/machine/RE.js';\n\nclass OverviewPanel extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n    }\n\n    /** @override */\n    render()\n    {\n        const drawer = this.props.drawer;\n        const session = this.props.session;\n        const currentModule = session.getCurrentModule();\n\n        const machineController = currentModule.getMachineController();\n        const drawerFull = drawer.isDrawerFullscreen();\n\n        return (\n            <PanelContainer id={this.props.id}\n                className={this.props.className}\n                style={this.props.style}\n                title={OverviewPanel.TITLE}>\n                <PanelSection title={'Terminals'} initial={true} full={drawerFull}>\n                    <AlphabetListView machineController={machineController}/>\n                </PanelSection>\n                <PanelSection title={'Symbol Key'} initial={true} full={true}>\n                    <table>\n                        <tbody>\n                            <tr><td>Epsilon</td><td>{EMPTY}</td></tr>\n                            <tr><td>Union</td><td>{UNION}</td></tr>\n                            <tr><td>Concat</td><td>{CONCAT}</td></tr>\n                            <tr><td>Kleene Star</td><td>{KLEENE}</td></tr>\n                            <tr><td>Kleene Plus</td><td>{PLUS}</td></tr>\n                            <tr><td>Sigma</td><td>{SIGMA}</td></tr>\n                            <tr><td>Empty Set</td><td>{EMPTY_SET}</td></tr>\n                        </tbody>\n                    </table>\n                </PanelSection>\n            </PanelContainer>\n        );\n    }\n}\nObject.defineProperty(OverviewPanel, 'TITLE', {\n    get: function() { return I18N.toString('component.overview.title'); }\n});\n\nexport default OverviewPanel;\n","import React from 'react';\nimport Style from './AnalysisPanel.css';\n\nimport PanelContainer from 'experimental/panels/PanelContainer.js';\nimport PanelSection from 'experimental/panels/PanelSection.js';\n\nclass AnalysisPanel extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n\n        this.onConvertToNFA = this.onConvertToNFA.bind(this);\n    }\n\n    onConvertToNFA(e)\n    {\n        this.props.session.getApp().getExportManager().tryExportFile('re2fsa', this.props.session);\n    }\n\n    /** @override */\n    render()\n    {\n        // const session = this.props.session;\n\n        return (\n            <PanelContainer id={this.props.id}\n                className={this.props.className}\n                style={this.props.style}\n                title={AnalysisPanel.TITLE}>\n                <PanelSection title={'Optimizations'} initial={true}>\n                    <button className={Style.analysis_button} onClick={this.onConvertToNFA}>\n                        {I18N.toString('action.overview.convertnfa')}\n                    </button>\n                </PanelSection>\n                <PanelSection title={'Related Machines'}>\n                </PanelSection>\n            </PanelContainer>\n        );\n    }\n}\nObject.defineProperty(AnalysisPanel, 'TITLE', {\n    get: function() { return I18N.toString('component.analysis.title'); }\n});\n\nexport default AnalysisPanel;\n","import React from 'react';\nimport Style from './TestItem.css';\n\nimport IconButton from 'experimental/components/IconButton.js';\nimport SubtractIcon from 'components/iconset/SubtractIcon.js';\nimport CheckCircleIcon from 'components/iconset/CheckCircleIcon.js';\nimport CrossCircleIcon from 'components/iconset/CrossCircleIcon.js';\nimport PendingIcon from 'components/iconset/PendingIcon.js';\nimport RunningManIcon from 'components/iconset/RunningManIcon.js';\n\nexport const DEFAULT_MODE = 'default';\nexport const SUCCESS_MODE = 'success';\nexport const FAILURE_MODE = 'failure';\nexport const WORKING_MODE = 'working';\n\nclass TestItem extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n\n        this.inputElement = null;\n\n        this.state = {\n            value: this.props.defaultValue || '',\n            status: DEFAULT_MODE\n        };\n\n        this.onChange = this.onChange.bind(this);\n    }\n\n    focus()\n    {\n        if (this.inputElement)\n        {\n            this.inputElement.focus();\n        }\n    }\n\n    setValue(value, callback=null)\n    {\n        if (this.state.value !== value)\n        {\n            this.setState({value: value}, callback);\n        }\n        else if (callback)\n        {\n            callback();\n        }\n    }\n\n    setStatus(status, callback=null)\n    {\n        if (this.state.status !== status)\n        {\n            this.setState({status: status}, callback);\n        }\n        else if (callback)\n        {\n            callback();\n        }\n    }\n\n    resetStatus(callback=null)\n    {\n        if (this.state.status !== DEFAULT_MODE)\n        {\n            this.setState({status: DEFAULT_MODE}, callback);\n        }\n        else if (callback)\n        {\n            callback();\n        }\n    }\n\n    getValue()\n    {\n        return this.state.value;\n    }\n\n    getStatus()\n    {\n        return this.state.status;\n    }\n\n    onChange(e)\n    {\n        const nextValue = e.target.value;\n        if (this.state.value !== nextValue)\n        {\n            this.setState({value: nextValue, status: DEFAULT_MODE});\n        }\n    }\n\n    /** @override */\n    render()\n    {\n        const onDelete = this.props.onDelete;\n        const showDelete = true;\n\n        const onTest = this.props.onTest;\n        const showTest = true;\n\n        const active = this.props.active;\n        // const subtitle = this.props.subtitle;\n        const placeholder = this.props.placeholder;\n        const status = this.state.status;\n\n        return (\n            <div id={this.props.id}\n                className={Style.test_item_container +\n          (active ? ' active ' : '') +\n          ' ' + status +\n          ' ' + this.props.className}\n                style={this.props.style}>\n                {showTest &&\n          <IconButton className={Style.test_button}\n              title={'Test'}\n              disabled={!onTest}\n              onClick={(e) => onTest(e, this)}>\n              {status === SUCCESS_MODE ?\n                  <CheckCircleIcon/> :\n                  status === FAILURE_MODE ?\n                      <CrossCircleIcon/> :\n                      status === WORKING_MODE ?\n                          <PendingIcon/> :\n                          <RunningManIcon/>}\n          </IconButton>}\n                <div className={Style.test_input}>\n                    <input ref={ref=>this.inputElement=ref} type=\"text\"\n                        placeholder={placeholder}\n                        value={this.state.value}\n                        onChange={this.onChange}/>\n                    <label>{this.props.subtitle}</label>\n                </div>\n                {showDelete &&\n          <IconButton className={Style.delete_button}\n              title={'Delete'}\n              disabled={!onDelete}\n              onClick={(e) => onDelete(e, this)}>\n              <SubtractIcon/>\n          </IconButton>}\n            </div>\n        );\n    }\n}\n\nexport default TestItem;\n","import React from 'react';\nimport Style from './TestListView.css';\n\nimport { guid } from 'util/MathHelper.js';\nimport { downloadText } from 'util/Downloader.js';\n\nimport IconButton from 'experimental/components/IconButton.js';\nimport IconUploadButton from 'experimental/components/IconUploadButton.js';\n\nimport PageContentIcon from 'components/iconset/PageContentIcon.js';\nimport UploadIcon from 'components/iconset/UploadIcon.js';\nimport DownloadIcon from 'components/iconset/DownloadIcon.js';\nimport CrossIcon from 'components/iconset/CrossIcon.js';\nimport AddIcon from 'components/iconset/AddIcon.js';\nimport RunningManIcon from 'components/iconset/RunningManIcon.js';\n\nimport TestItem, {SUCCESS_MODE, FAILURE_MODE, WORKING_MODE} from './TestItem.js';\n\nimport {solveFSA} from 'modules/fsa2/machine/FSAUtils.js';\n\nconst ACCEPT_FILE_TYPES = ['.txt'];\nconst TEST_FILENAME = 'test.txt';\n// const TEST_REFRESH_TICKS = 30;\n\nclass TestListView extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n\n        this._testList = [];\n        this._testName = TEST_FILENAME;\n\n        this.onTestNew = this.onTestNew.bind(this);\n        this.onTestUpload = this.onTestUpload.bind(this);\n        this.onTestDownload = this.onTestDownload.bind(this);\n        this.onTestClose = this.onTestClose.bind(this);\n        this.onTestAdd = this.onTestAdd.bind(this);\n        this.onTestDelete = this.onTestDelete.bind(this);\n        this.onTestTest = this.onTestTest.bind(this);\n        this.onTestRunAll = this.onTestRunAll.bind(this);\n        this.onExpressionChange = this.onExpressionChange.bind(this);\n    }\n\n    /** @override */\n    componentDidMount()\n    {\n        this.props.machineController.getExpressionChangeHandler().addListener(this.onExpressionChange);\n    }\n\n    /** @override */\n    componentWillUnmount()\n    {\n        this.props.machineController.getExpressionChangeHandler().removeListener(this.onExpressionChange);\n    }\n\n    onExpressionChange(expression)\n    {\n        for(const test of this._testList)\n        {\n            test.ref.resetStatus();\n        }\n    }\n\n    onTestNew(e)\n    {\n        if (!this.isEmpty())\n        {\n            this.onTestClose(e);\n        }\n\n        this.onTestAdd(e);\n    }\n\n    onTestUpload(fileBlob)\n    {\n        const reader = new FileReader();\n        reader.onload = (event) => \n        {\n            try\n            {\n                this._testName = fileBlob.name;\n                this._testList.length = 0;\n\n                const tests = event.target.result.split('\\n');\n                for(let test of tests)\n                {\n                    test = test.trim();\n                    if (test.length > 0)\n                    {\n                        this._testList.push({\n                            id: guid(),\n                            defaultValue: test,\n                            ref: null\n                        });\n                    }\n                }\n\n                //Make sure an element exists, at least\n                if (this._testList.length <= 0)\n                {\n                    this.onTestAdd(null);\n                }\n            }\n            catch(e)\n            {\n                reader.abort();\n            }\n        };\n        reader.readAsText(fileBlob);\n    }\n\n    onTestDownload(e)\n    {\n        const testStrings = [];\n        for(const test of this._testList)\n        {\n            const ref = test.ref;\n            if (ref)\n            {\n                testStrings.push(ref.getValue());\n            }\n        }\n\n        downloadText(this._testName, testStrings.join('\\n'));\n    }\n\n    onTestClose(e)\n    {\n        this._testList.length = 0;\n    }\n\n    onTestAdd(e)\n    {\n        this._testList.push({\n            id: guid(),\n            defaultValue: '',\n            ref: null\n        });\n    }\n\n    onTestRunAll(e)\n    {\n        let i = 0;\n\n        const nextTest = () => \n        {\n            const test = this._testList[i];\n            this.onTestTest(null, test.ref, () => \n            {\n                ++i;\n                if (i < this._testList.length)\n                {\n                    nextTest();\n                }\n            });\n        };\n        nextTest();\n    }\n\n    onTestDelete(e, item)\n    {\n    //Already handled in render()\n    }\n\n    onTestTest(e, item, callback=null)\n    {\n        const itemValue = item.getValue();\n\n        item.setState({status: WORKING_MODE});\n\n        const machineController = this.props.machineController;\n        const fsa = machineController.getEquivalentFSA();\n        const result = solveFSA(fsa, itemValue);\n        item.setState({status: result ? SUCCESS_MODE : FAILURE_MODE});\n\n        if (callback)\n        {\n            callback();\n        }\n    }\n\n    isEmpty()\n    {\n        return this._testList.length <= 0;\n    }\n\n    /** @override */\n    render()\n    {\n        const machineController = this.props.machineController;\n\n        const empty = this.isEmpty();\n\n        return (\n            <div id={this.props.id}\n                className={Style.test_container +\n          ' ' + this.props.className}\n                style={this.props.style}>\n                <div className={Style.test_control_tray}>\n                    <IconButton className={Style.test_control_button}\n                        title={I18N.toString('action.testing.new')}\n                        onClick={this.onTestNew}>\n                        <PageContentIcon/>\n                    </IconButton>\n                    <IconUploadButton className={Style.test_control_button}\n                        title={I18N.toString('action.testing.import')}\n                        accept={ACCEPT_FILE_TYPES.join(',')}\n                        onUpload={this.onTestUpload}>\n                        <UploadIcon/>\n                    </IconUploadButton>\n                    <IconButton className={Style.test_control_button}\n                        title={I18N.toString('action.testing.save')}\n                        disabled={empty}\n                        onClick={this.onTestDownload}>\n                        <DownloadIcon/>\n                    </IconButton>\n                    <IconButton className={Style.test_control_button}\n                        title={I18N.toString('action.testing.clear')}\n                        disabled={empty}\n                        onClick={this.onTestClose}>\n                        <CrossIcon/>\n                    </IconButton>\n                </div>\n                <div className={Style.test_list_container +\n          (empty ? ' empty ' : '')}>\n                    <IconButton className={Style.test_list_add}\n                        title={'Add'} onClick={this.onTestAdd}>\n                        <AddIcon/>\n                        <span className={Style.test_list_count}>\n                            {!empty ? '' + this._testList.length : ''}\n                        </span>\n                    </IconButton>\n                    <div className={Style.test_list_scroll_container}>\n                        <div className={Style.test_list}>\n                            {this._testList.map((e, i) => \n                            {\n                                const id = e.id;\n                                const defaultValue = e['defaultValue'] || '';\n                                let testCallback = this.onTestTest;\n                                if (machineController.getMachineExpression().length === 0)\n                                {\n                                    testCallback = null;\n                                }\n                                return <TestItem key={id} ref={ref=>e.ref=ref}\n                                    defaultValue={defaultValue}\n                                    onTest={testCallback}\n                                    onDelete={(e, item) => \n                                    {\n                                        this._testList.splice(i, 1);\n                                        this.onTestDelete(e, item);\n                                    }}/>;\n                            })}\n                        </div>\n                    </div>\n                    <IconButton className={Style.test_list_runall}\n                        title={'Run All'} onClick={this.onTestRunAll}>\n                        <RunningManIcon/>\n                    </IconButton>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default TestListView;\n","import React from 'react';\nimport Style from './TestingPanel.css';\n\nimport PanelContainer from 'experimental/panels/PanelContainer.js';\nimport PanelSwitch from 'experimental/panels/PanelSwitch.js';\n\nimport TestListView from './TestListView.js';\n\nimport {MACHINE_ERROR_NOTIFICATION_TAG} from 'modules/re/components/notifications/RENotifications.js';\n\nclass TestingPanel extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n\n        this.onAutoErrorCheckChange = this.onAutoErrorCheckChange.bind(this);\n    }\n\n    onAutoErrorCheckChange(e)\n    {\n        const currentModule = this.props.session.getCurrentModule();\n        const errorChecker = currentModule.getErrorChecker();\n        const errorCheck = errorChecker.isErrorChecking();\n        errorChecker.setErrorChecking(!errorCheck);\n        if (errorCheck)\n        {\n            //Turning it off\n            this.props.session.getApp().getNotificationManager().clearNotifications(MACHINE_ERROR_NOTIFICATION_TAG);\n        }\n        else\n        {\n            const machineController = currentModule.getMachineController();\n            errorChecker.onExpressionChange(machineController.getMachineExpression());\n        }\n    }\n\n    /** @override */\n    render()\n    {\n        const session = this.props.session;\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n        const errorChecker = currentModule.getErrorChecker();\n\n        const errorCheck = errorChecker.isErrorChecking();\n\n        return (\n            <PanelContainer id={this.props.id}\n                className={Style.panel_container +\n          ' ' + this.props.className}\n                style={this.props.style}\n                title={TestingPanel.TITLE}>\n\n                <TestListView machineController={machineController}/>\n                <PanelSwitch id={'testing-error-check'} checked={errorCheck} onChange={this.onAutoErrorCheckChange} title={'Auto error checking'}/>\n\n            </PanelContainer>\n        );\n    }\n}\nObject.defineProperty(TestingPanel, 'TITLE', {\n    get: function() { return I18N.toString('component.testing.title'); }\n});\n\nexport default TestingPanel;\n","import React from 'react';\nimport Style from './ViewportView.css';\nimport ExpressionViewStyle from './ExpressionView.css';\n\nimport {EMPTY, CONCAT, UNION, KLEENE, SIGMA, EMPTY_SET, PLUS} from 'modules/re/machine/RE.js';\n\nconst UNION_CHAR = '\\u222A';\n\nclass ExpressionView extends React.Component\n{\n    constructor(props)\n    {\n        super(props);\n\n        this._inputElement = null;\n\n        this.onInputChange = this.onInputChange.bind(this);\n        this.onClick = this.onClick.bind(this);\n    }\n\n    onInputChange(e)\n    {\n        const session = this.props.session;\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n\n        const value = e.target.value;\n        const result = value.replace(new RegExp(UNION_CHAR, 'g'), UNION);\n\n        machineController.setMachineExpression(result);\n        session.getApp().getUndoManager().captureEvent();\n    }\n\n    onClick(e)\n    {\n        const session = this.props.session;\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n        const cursorPos = this._inputElement.selectionStart;\n\n        const scope = machineController._parser.scopeFromSpaceIndexing(machineController.getMachine(), cursorPos);\n        this._inputElement.setSelectionRange(scope[0][0], scope[1][1]);\n    }\n\n    _appendSymbol(machineController, symbol)\n    {\n        const session = this.props.session;\n        const currentExpression = machineController.getMachineExpression();\n        const cursorPos = this._inputElement.selectionStart;\n        const newExpression = currentExpression.slice(0, cursorPos) + symbol + currentExpression.slice(cursorPos);\n        machineController.setMachineExpression(newExpression);\n        session.getApp().getUndoManager().captureEvent();\n        this._inputElement.focus();\n    }\n\n    /** @override */\n    render()\n    {\n        const session = this.props.session;\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n        const terminals = machineController.getMachineTerminals();\n        const error = !machineController.getMachine().isValid();\n\n        const readableValue = machineController.getMachineExpression().replace(new RegExp(UNION, 'g'), UNION_CHAR);\n\n        return (\n            <div id={this.props.id}\n                className={Style.view_pane +\n          ' ' + this.props.className}\n                style={this.props.style}>\n                <div className={Style.view_widget + ' ' +\n          ExpressionViewStyle.expression + ' ' +\n          (error ? 'error' : '')}>\n                    <input ref={ref=>this._inputElement=ref} value={readableValue} onChange={this.onInputChange} onClick={this.onClick}/>\n                </div>\n                <div className={Style.view_widget + ' ' + ExpressionViewStyle.expression_tray + ' ' + ExpressionViewStyle.tray_important}>\n                    <button title=\"Epsilon\"       onClick={() => {this._appendSymbol(machineController, EMPTY);}}>{EMPTY}</button>\n                    <button title=\"Union\"         onClick={() => {this._appendSymbol(machineController, UNION);}}>{UNION_CHAR}</button>\n                    <button title=\"Concat\"        onClick={() => {this._appendSymbol(machineController, CONCAT);}}>{CONCAT}</button>\n                    <button title=\"Kleene Star\"   onClick={() => {this._appendSymbol(machineController, KLEENE);}}>{KLEENE}</button>\n                    <button title=\"Kleene Plus\"   onClick={() => {this._appendSymbol(machineController, PLUS);}}>{PLUS}</button>\n                    <button title=\"Sigma\"         onClick={() => {this._appendSymbol(machineController, SIGMA);}}>{SIGMA}</button>\n                    <button title=\"Empty Set\"     onClick={() => {this._appendSymbol(machineController, EMPTY_SET);}}>{EMPTY_SET}</button>\n                </div>\n\n                <div className={Style.view_widget + ' ' + ExpressionViewStyle.expression_tray + ' ' + ExpressionViewStyle.tray_symbol}>\n                    {terminals.map(e => \n                    {\n                        return (\n                            <button key={e} onClick={() => {this._appendSymbol(machineController, e);}}>{e}</button>\n                        );\n                    })}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default ExpressionView;\n","import SessionImporter from 'session/SessionImporter.js';\n\nclass REImporter extends SessionImporter\n{\n    constructor(app)\n    {\n        super(app);\n\n        this._prevExpression = '';\n    }\n\n    /** @override */\n    onParseSession(session, fileData)\n    {\n        return JSON.parse(fileData);\n    }\n\n    /** @override */\n    onPreImportSession(session)\n    {\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n        this._prevExpression = machineController.getMachineExpression();\n\n        // TODO: this should not be here, this should exist somewhere in graphController\n        if (!this._prevExpression)\n        {\n            session.getApp().getUndoManager().captureEvent();\n        }\n    }\n\n    /** @override */\n    onImportSession(session, sessionData)\n    {\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n\n        const machineExpression = sessionData['machineData']['expression'];\n        if (machineExpression) machineController.setMachineExpression(machineExpression);\n    }\n\n    /** @override */\n    onPostImportSession(session)\n    {\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n\n        // Compares the graph hash before and after import, captures event if they are not equal\n        const nextExpression = machineController.getMachineExpression();\n        if (this._prevExpression !== nextExpression)\n        {\n            // TODO: this should not be here\n            session.getApp().getUndoManager().captureEvent();\n        }\n    }\n}\n\nexport default REImporter;\n","import SessionExporter from 'session/SessionExporter.js';\n\nimport JSONFileIcon from 'components/iconset/flat/JSONFileIcon.js';\n\nclass REExporter extends SessionExporter\n{\n    constructor()\n    {\n        super('.re.json');\n    }\n\n    /** @override */\n    onExportSession(session, dst)\n    {\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n\n        dst['machineData'] = {\n            expression: machineController.getMachineExpression()\n        };\n    }\n    \n    /** @override */\n    getIconClass() { return JSONFileIcon; }\n    /** @override */\n    getLabel() { return I18N.toString('file.export.machine'); }\n    /** @override */\n    getTitle() { return I18N.toString('file.export.machine.hint'); }\n}\n\nexport default REExporter;\n","import SessionExporter from 'session/SessionExporter.js';\n\nimport JSONFileIcon from 'components/iconset/flat/JSONFileIcon.js';\nimport { JSON as JSONGraphParser } from 'modules/fsa2/FSAGraphParser.js';\n\nimport FSAGraph from 'modules/fsa2/graph/FSAGraph.js';\nimport {EMPTY_SYMBOL} from 'modules/fsa2/machine/FSA.js';\nimport {EMPTY_CHAR, SYMBOL_SEPARATOR} from 'modules/fsa2/graph/element/FSAEdge.js';\nimport GraphLayout from 'modules/fsa2/GraphLayout.js';\n\nclass REToFSAExporter extends SessionExporter\n{\n    constructor() { super('.fsa.json'); }\n\n    onExportSession(session, dst)\n    {\n        const currentModule = session.getCurrentModule();\n        const machineController = currentModule.getMachineController();\n        const machine = machineController.getEquivalentFSA();\n\n        const graph = new FSAGraph();\n        setGraphToFSA(graph, machine);\n        const graphData = JSONGraphParser.objectify(graph);\n\n        dst['graphData'] = graphData;\n        dst['machineData'] = {\n            type: 'NFA',\n            symbols: []\n        };\n    }\n    \n    /** @override */\n    getIconClass() { return JSONFileIcon; }\n    /** @override */\n    getLabel() { return I18N.toString('file.export.convertfsa'); }\n    /** @override */\n    getTitle() { return I18N.toString('file.export.convertfsa'); }\n}\n\nfunction setGraphToFSA(graph, machine)\n{\n    graph.clear();\n\n    if (machine.getStateCount() <= 0) return;\n\n    //Add all states\n    let stateMap = new Map();\n    let node;\n    for(const state of machine.getStates())\n    {\n        node = graph.createNode(0, 0);\n        node.setNodeLabel(state.getStateLabel());\n        if (machine.isFinalState(state)) node.setNodeAccept(true);\n        stateMap.set(state, node);\n    }\n\n    //Add all transitions\n    let edge, from, to, read;\n    for(let transition of machine.getTransitions())\n    {\n        from = stateMap.get(transition.getSourceState());\n        to = stateMap.get(transition.getDestinationState());\n        read = [];\n        for(const symbol of transition.getSymbols())\n        {\n            if (symbol === EMPTY_SYMBOL)\n            {\n                read.push(EMPTY_CHAR);\n            }\n            else\n            {\n                read.push(symbol);\n            }\n        }\n        edge = graph.createEdge(from, to);\n        edge.setEdgeLabel(read.join(SYMBOL_SEPARATOR));\n        const formattedEdge = graph.formatEdge(edge);\n        if (edge != formattedEdge) graph.deleteEdge(edge);\n    }\n\n    //Set start state\n    const startState = machine.getStartState();\n    graph.setStartNode(stateMap.get(startState));\n\n    //Auto layout graph\n    GraphLayout.applyLayout(graph);\n}\n\nexport default REToFSAExporter;\n","import React from 'react';\nimport PanelContainer from 'experimental/panels/PanelContainer.js';\n\nimport MachineController from './MachineController.js';\nimport REErrorChecker from './REErrorChecker.js';\nimport SafeExpressionEventHandler from './SafeExpressionEventHandler.js';\nimport { RENDER_LAYER_WORKSPACE } from 'session/manager/RenderManager.js';\n\nimport { registerNotifications } from './components/notifications/RENotifications.js';\n\nimport OverviewPanel from './components/panels/overview/OverviewPanel.js';\nimport AnalysisPanel from './components/panels/analysis/AnalysisPanel.js';\nimport TestingPanel from './components/panels/testing/TestingPanel.js';\n\nimport ExpressionView from './components/views/ExpressionView.js';\nimport { CTRL_KEY, SHIFT_KEY } from 'session/manager/hotkey/HotKeyManager.js';\n\nimport REImporter from './filehandlers/REImporter.js';\nimport REExporter from './filehandlers/REExporter.js';\nimport REToFSAExporter from './filehandlers/REToFSAExporter.js';\n\nconst MODULE_NAME = 're';\nconst MODULE_VERSION = '0.0.1';\nconst MODULE_LOCALIZED_NAME = 'RE';\n\nclass REModule\n{\n    constructor(app)\n    {\n        this._app = app;\n\n        this._machineController = new MachineController();\n        this._errorChecker = new REErrorChecker(app,\n            this._machineController);\n\n        app.getRenderManager()\n            .addRenderer(RENDER_LAYER_WORKSPACE, props => <ExpressionView session={app.getSession()} />);\n    }\n\n    /** @override */\n    initialize(app)\n    {\n        registerNotifications(app.getNotificationManager());\n\n        app.getDrawerManager()\n            .addPanelClass(props => (\n                <PanelContainer id={props.id}\n                    className={props.className}\n                    style={props.style}\n                    title={'Regular Expressions'}>\n                    <p>{'Brought to you with \\u2764 by the Flap.js team.'}</p>\n                    <p>{'<- Tap on a tab to begin!'}</p>\n                </PanelContainer>\n            ))\n            .addPanelClass(OverviewPanel)\n            .addPanelClass(AnalysisPanel)\n            .addPanelClass(TestingPanel);\n\n        app.getUndoManager()\n            .setEventHandlerFactory((...args) =>\n                new SafeExpressionEventHandler(this._machineController));\n\n        app.getExportManager()\n            .registerExporter(new REExporter(), 'session')\n            .registerExporter(new REToFSAExporter(), 're2fsa');\n\n        app.getImportManager()\n            .addImporter(new REImporter(app), '.re.json', '.json');\n\n        app.getHotKeyManager()\n            .registerHotKey('Save as JSON', [CTRL_KEY, 'KeyS'], () => { app.getExportManager().tryExportFile('session', app.getSession()); })\n            .registerHotKey('New', [CTRL_KEY, 'KeyN'], () => { this.clear(app); })\n            .registerHotKey('Undo', [CTRL_KEY, 'KeyZ'], () => { app.getUndoManager().undo(); })\n            .registerHotKey('Redo', [CTRL_KEY, SHIFT_KEY, 'KeyZ'], () => { app.getUndoManager().redo(); });\n    }\n\n    /** @override */\n    update(app)\n    {\n        this._machineController.update();\n    }\n\n    /** @override */\n    destroy(app)\n    {\n    }\n\n    /** @override */\n    clear(app)\n    {\n        if (window.confirm(I18N.toString('alert.graph.clear')))\n        {\n            this._machineController.setMachineExpression('');\n            app.getUndoManager().clear();\n            app.getSession().setProjectName(null);\n            app.getToolbarComponent().closeBar();\n        }\n    }\n\n    getMachineController() { return this._machineController; }\n    getErrorChecker() { return this._errorChecker; }\n\n    /** @override */\n    getModuleVersion() { return MODULE_VERSION; }\n    /** @override */\n    getModuleName() { return MODULE_NAME; }\n    /** @override */\n    getLocalizedModuleName() { return MODULE_LOCALIZED_NAME; }\n    /** @override */\n    getApp() { return this._app; }\n}\n\nexport default REModule;\n"],"sourceRoot":""}